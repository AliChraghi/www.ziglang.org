<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learn on Zig Programming Language</title><link>//ziglang.github.io/www.ziglang.org/learn/</link><description>Recent content in Learn on Zig Programming Language</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="//ziglang.github.io/www.ziglang.org/learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Code Examples</title><link>//ziglang.github.io/www.ziglang.org/learn/samples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/samples/</guid><description>Memory leak detection Using std.GeneralPurposeAllocator you can track double frees and memory leaks.
leak.zig
const std = @import(&amp;quot;std&amp;quot;); pub fn main() !void { var gpalloc = std.heap.GeneralPurposeAllocator(.{}){}; defer std.debug.assert(!gpalloc.deinit()); const alloc = &amp;amp;gpalloc.allocator; const u32_ptr = try alloc.create(u32); // oops I forgot to free! }$ zig build-exe leak.zig $ ./leak error(std): Memory leak detected: /home/runner/work/www.ziglang.org/www.ziglang.org/doctest-c1cf2d3c/leak.zig:9:37: 0x22dfa4 in main (leak) const u32_ptr = try alloc.create(u32); ^ /home/runner/work/www.ziglang.org/zig/lib/std/start.zig:345:37: 0x205704 in std.start.posixCallMainAndExit (leak) const result = root.</description></item><item><title>Getting Started</title><link>//ziglang.github.io/www.ziglang.org/learn/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/getting-started/</guid><description>Note for Apple Silicon users Zig has experimental support for codesigning. You will be able to use Zig with your M1 Mac, but the only way at the moment to get Zig for arm64 macOS is to compile it yourself. Make sure to check the Building from source section.
Tagged release or nightly build? Zig has not yet reached v1.0 and the current release cycle is tied to new releases of LLVM, which have a ~6 months cadence.</description></item><item><title>In-depth Overview</title><link>//ziglang.github.io/www.ziglang.org/learn/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/overview/</guid><description>Feature Highlights Small, simple language Focus on debugging your application rather than debugging your programming language knowledge.
Zig&amp;rsquo;s entire syntax is specified with a 500-line PEG grammar file.
There is no hidden control flow, no hidden memory allocations, no preprocessor, and no macros. If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:</description></item><item><title>Tools</title><link>//ziglang.github.io/www.ziglang.org/learn/tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/tools/</guid><description>Language Servers Language servers are editor-agnostic tools for obtaining syntax highlighting, autocompletion, and many other features. Consider using a Language server over a syntax-highlighting extension for a richer development experience.
zigtools/zls Text Editors Editor-specific tools, mostly syntax highlighters.
VS Code ziglang/vscode-zig Sublime Text ziglang/sublime-zig-language Vim ziglang/zig.vim Emacs ziglang/zig-mode Kate ziglang/kde-syntax-highlighting Documentation and Testing kristoff-it/zig-doctest</description></item><item><title>Why Zig When There is Already C++, D, and Rust?</title><link>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</guid><description>No hidden control flow If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:
var a = b + c.d; foo(); bar(); D has @property functions, which are methods that you call with what looks like field access, so in the above example, c.</description></item></channel></rss>