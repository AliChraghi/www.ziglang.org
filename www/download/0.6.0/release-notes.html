<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>0.6.0 Release Notes &middot; The Zig Programming Language</title>
    <link rel="icon" href="https://ziglang.org/favicon.png">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        line-height: 1.45;
        margin-left: 0;
        margin-right: 0;
      }
      p {
        margin: 0.8em 0;
      }

      h1, h2, h3, h4, h5 {
        margin: 0.5em 0 0.5em;
        line-height: 1.2;
        font-weight: bold;
        color: #666;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #666;
      }

      h1 { font-size: 2.0em; }
      
      h2 { font-size: 1.5em; }
      
      h3 { font-size: 1.25em; }

      h4 { font-size: 1.0em; }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      a {
        color: #2A6286;
      }
      
      a:not(:hover) {
        text-decoration: none;
      }

      th, td {
        padding: 0.6em;
        text-align: left;
      }
      
      td {
        font-size: 0.96em;
      }
      
      th {
        border-bottom: 2px solid #f2f3f3;
      }
      
      tr:nth-child(even) {
        background: #f2f3f3;
      }
      
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      pre,code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        color: #333;
        background: #f8f8f8;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #0086b3;
      }
      .tok-comment {
          color: #777;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #008080;
      }
      .tok-number {
          color: #008080;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 0.2em;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background-color:#111;
            color: #bbb;
        }
        a {
            color: #88f;
        }
        table, th, td {
            border-color: grey;
        }
        tr:nth-child(even) {
          background: #1e1e1e;
        }
        .t2_0 {
            color: grey;
        }
        .t31_1 {
            color: red;
        }
        .t32_1 {
            color: green;
        }
        .t36_1 {
            color: #0086b3;
        }
        pre > code {
            color: #ccc;
            background: #222;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #e33;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1, h2, h3, h4, h5 {
          color: #aaa;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
      }
    </style>
  </head>
  <!--
                                 .m//oooo/:.```h``y +/```.:/+++/oyo                                  
                               `:yNy+-``       h` s +/       ``-/yds:`                              
                             -sdy/.            h` s +/            `:sho-                            
                           :yh+.               h` o +/               `/yy-                          
                         -yh/`                 h` + +/                 `-yy.                        
                       `oh/........```         h` / +/           ``.....``:h+`                      
                      .hNhyyyyysssoo++/-`      h` / +/      `.-:/+oooossssoomy.                      
                     -mmdyyso+++++++o+++o/-`   h` : +/   `.:+/++++/////++oyyhNd-                    
                    -myoso++/:::::-.....-/+/-  h` - +/  .:+/-.....-:::::/++ossdm.                    
                   .ms-ysossyhyyyyhyyso:.``:+/`o+ .`y-`/o:` .:+syhhhhhhhyssooh/hd`                  
                   yh-hshysshhdmmddhysyhy+-` :s:+o.y:-s/` .+yhyyhdmmmmmddhyyhsh/ms                  
                  :N.yshohNMMMNMMMMMMMmyohy+` `y//h:-h. `/yhyhmMMMMMMNMMMMMdshyy/N-                  
                  hs:om+NMMMMMMMNMMMMMMMNsyh+` `d.``d- `+yhyNMMMMMMNNMMMMMMMMsdo/hs                  
                 `N-/yomMMMMMMMMMNNMMMMMMM+hs+  os +y  /omoMMMMMMMNMMMMMMMMMMN+d//m                  
                 -N :d/MMMMMMMMMMMMNMMMMMMm+do  /h oo  +ysmMMMMMNMMMMMMMMMMMMM+N/.N.                
                 :m :d+MMMMMMMMMMMMMMNMMMMhsy+``s+ :h``/ohhMMMNMMMMMMMMMMMMMMM+N:`N.                
                 -N :h+MMMMMMMMMMMMMMMMNMmodo-~/h`. y+~-ohsmNNMMMMMMMMMMMMMMMM+m:`N.                
                 `N..ssdMMMMMMMMMMMMMMMNhsho/:+y` / `so/:oyyhNMMMMMMMMMMMMMMMNoy~-m`                
                  h/ +moMMMMMMMMMMMMMMmsyso++so`  o   +s++oshymMMMMMMMMMMMMMMydo`+y                  
                  /d :homMMMMMMMMMMMmyyyooosy:   .o.`  -ssoosyyymMMMMMMMMMMMN+d: d-                  
                   d/ +m+mNMMMMMMNdyyysssss/`    :s/.    :ysssoyyyhNMMMMMMMN+do`+y                  
                   .d-.ohshNNNNdyyyysyhsy+-`  ```+s+:`  ```:shsyyyhyyhNNNNd+hy..d.                  
                   .+h..+dhyyhodyyydyhy/.~-` ..`.yss+``-.`. .+ohydhhyhshyyyho:.h:                    
                    ./h- ++yydsmdmhh+/+..~-  -...yyd+  `.....+-~/sdmddydhy+:.:h:                    
                   `..:hoo//:/.-:.:o+/++:-:- .~-:+/s+:-...:-:++/+:~-:-`/::+ohd..-`                  
                       `smhsooososooo+++/::.~-.`   `  .::-:///+++sosoosssyhmo`                      
                         :dmdmdhyysyoso+o/::`      /  `.-~/+ooosssyyhhddmNh-                        
                          `/dMMmmhdyyyss/-         +     -:-/syshyddmNMMh:                          
                            `:yNMNNmho/.           +      `-:::shmNMMNy-                            
                               ./dh/.`             +         .::/omy/`                              
                       ./o-      `++               +           `.y/         -o/.                    
                  `-/+o+/d/+`      /y:/oy:     .///y///.     /yooo.`      `o/h/+++/.                
              `-/+o+//+::d`.+-   .sooooooh-  `o/:/:+:/:/+`  :hoooo+os`   -s. h:////+o+/-`            
          `-/+o+/+/:/+:/+y/ `+:  `hsooooooh. o-/hoyhyoh/:o -hoooooosy`  /o` /y+/:+/:///+o+:-`        
        -so+++:/+/://:/+:/d. `//  -doooooosy`h-oNyMMMyNo:h.yoooooood.  ++` `d/:+/://:/+::+++oo.      
        d+://://:/+/://:/+os  `sosdNdoooooosy+/:yhhdhhy:/+yooooooodNdsss`  so+/://://:/+/://:+y      
       .h///://:///://://:/y+ :NMMMMMhooooooss////+s+//+/ssoooooodMMMMMN/ +y/://://:///://://:h      
       `d+/:+/://:/+/://://:y/`mMMMMMNyooooooy+`-:/+/:-`oyoooooohMMMMMMN.:y///://:///://://:/+h      
        y////://://:///://:/+h::mMMMmhysooooooy/       +yooooooyyhmMMMm:-h+/://:///://://:////o      
        -y/:/+/://://:///://:/h:.+:s: `ysooooooy      `hooooooys  /y/+.-h/://://:///://://::/y.      
         o+//:///://://:/+/:///y:  `s` `yss+/-.`  .-://+syyyoss` .y`  :y///://:/+/://://:///++      
         `y+:///://://:///://:/+y/  .o  `sh    ``.://+osyhNN~-` `y.  /y+/://:/+/://://:///:+s`      
          .y+/:///:+/://:/+/://:/so` //  +d-///////++++oydNd    +/ `oy/://:/+/://://:/+/:/+o`        
           .s///:/+/://://:/+/:+/:+s-`s` sh-:oy:-----:+o~-yh   .y`-so://:/+::+/://:/+::///o`        
            .so:/+::+/://:/+:/+/:///o+y/ /s:mdo       .md-s/   +y+o///:/+:/+/://:/+:/+/:+o`          
             `+s+:/+::+/://:/+::+//+ooo.  `:yy+       /yy:`    -ooo+//+:/+/://:/+:/+/:+o/            
               -so+:/+/:+/:/+/+o+//-`       `+s-`o:`-/s+          `-//+o+/+/:/+:/+::+++.            
                 :oso//+/+so//-`              `-:::::-`                `-/+os//+//+o+:              
                   ./os+/-`                                                 `:/+s+:.
  -->
  <body>
    <div id="contents">
    <a href="https://ziglang.org/"><img alt="zig" src="https://ziglang.org/zig-logo.svg" style="width: 28em"></a>
    <h1>0.6.0 Release Notes</h1>
    <p>
    <a href="https://ziglang.org/download/">Download &amp; Documentation</a>
    </p>
    <p>
    Zig is a general-purpose programming language and toolchain for maintaining
    <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software.
    With special thanks to
    <a href="https://github.com/users/andrewrk/sponsorship">many generous sponsors</a>,
    the Zig project is financially sustainable and currently supports
    <a href="https://andrewkelley.me/">one full-time developer</a>.
    Let's reboot systems programming.</p>
    <p>
    This release features <strong>6 months of work</strong> and
    changes from <strong>112 different contributors</strong>, spread among
    <strong>2510 commits</strong>.
    </p>

    <h1 id="Table-of-Contents"><a href="#toc-Table-of-Contents">Table of Contents</a> <a class="hdr" href="#Table-of-Contents">ยง</a></h1>

    

    <ul>
        <li><a id="toc-Table-of-Contents" href="#Table-of-Contents">Table of Contents</a></li>
        <li><a id="toc-LLVM-10" href="#LLVM-10">LLVM 10</a></li>
        <li><a id="toc-Bootstrap-Tarball" href="#Bootstrap-Tarball">Bootstrap Tarball</a></li>
        <li><a id="toc-Support-Table" href="#Support-Table">Support Table</a>
        <ul>
            <li><a id="toc-WebAssembly-Support" href="#WebAssembly-Support">WebAssembly Support</a></li>
            <li><a id="toc-Tier-System" href="#Tier-System">Tier System</a>
            <ul>
                <li><a id="toc-Tier-1-Support" href="#Tier-1-Support">Tier 1 Support</a></li>
                <li><a id="toc-Tier-2-Support" href="#Tier-2-Support">Tier 2 Support</a></li>
                <li><a id="toc-Tier-3-Support" href="#Tier-3-Support">Tier 3 Support</a></li>
                <li><a id="toc-Tier-4-Support" href="#Tier-4-Support">Tier 4 Support</a></li>
            </ul></li>
            <li><a id="toc-Windows-Support" href="#Windows-Support">Windows Support</a>
            <ul>
                <li><a id="toc-32-bit-Windows-Support" href="#32-bit-Windows-Support">32-bit Windows Support</a></li>
            </ul></li>
            <li><a id="toc-RISC-V-Support" href="#RISC-V-Support">RISC-V Support</a></li>
            <li><a id="toc-ARM-Support" href="#ARM-Support">ARM Support</a></li>
            <li><a id="toc-32-bit-x86-Support" href="#32-bit-x86-Support">32-bit x86 Support</a></li>
            <li><a id="toc-MIPS-Support" href="#MIPS-Support">MIPS Support</a></li>
            <li><a id="toc-NetBSD-Support" href="#NetBSD-Support">NetBSD Support</a></li>
            <li><a id="toc-UEFI-Support" href="#UEFI-Support">UEFI Support</a></li>
            <li><a id="toc-macOS-Support" href="#macOS-Support">macOS Support</a></li>
        </ul></li>
        <li><a id="toc-Target-Details" href="#Target-Details">Target Details</a>
        <ul>
            <li><a id="toc-CPU-Features" href="#CPU-Features">CPU Features</a></li>
            <li><a id="toc-Removal-of-Sub-Architecture" href="#Removal-of-Sub-Architecture">Removal of Sub-Architecture</a></li>
            <li><a id="toc-OS-Version-Ranges" href="#OS-Version-Ranges">OS Version Ranges</a></li>
        </ul></li>
        <li><a id="toc-Language-Changes" href="#Language-Changes">Language Changes</a>
        <ul>
            <li><a id="toc-Type-Coercion-Syntax" href="#Type-Coercion-Syntax">Type Coercion Syntax</a></li>
            <li><a id="toc-Sentinel-Terminated-Pointers" href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a></li>
            <li><a id="toc-Remove-Array-to-Reference-Type-Coercion" href="#Remove-Array-to-Reference-Type-Coercion">Remove Array-to-Reference Type Coercion</a></li>
            <li><a id="toc-Numerical-Comparisons" href="#Numerical-Comparisons">Numerical Comparisons</a></li>
            <li><a id="toc-Anonymous-Struct-Literals" href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a></li>
            <li><a id="toc-Tuples-Added-Var-Args-Removed" href="#Tuples-Added-Var-Args-Removed">Tuples Added, Var Args Removed</a></li>
            <li><a id="toc-SIMD" href="#SIMD">SIMD</a></li>
            <li><a id="toc-newStackCall-Removed" href="#newStackCall-Removed">@newStackCall Removed</a></li>
            <li><a id="toc-call" href="#call">@call</a></li>
            <li><a id="toc-callconv" href="#callconv">callconv</a></li>
            <li><a id="toc-Non-Exhaustive-Enums" href="#Non-Exhaustive-Enums">Non-Exhaustive Enums</a></li>
            <li><a id="toc-Unicode-Character-Literals" href="#Unicode-Character-Literals">Unicode Character Literals</a></li>
            <li><a id="toc-Atomics" href="#Atomics">Atomics</a></li>
            <li><a id="toc-Container-Level-Doc-Comments" href="#Container-Level-Doc-Comments">Container-Level Doc Comments</a></li>
            <li><a id="toc-Comptime-Struct-Fields" href="#Comptime-Struct-Fields">Comptime Struct Fields</a></li>
            <li><a id="toc-Untyped-Struct-Fields" href="#Untyped-Struct-Fields">Untyped Struct Fields</a></li>
            <li><a id="toc-Pointer-Arithmetic-and-Alignment" href="#Pointer-Arithmetic-and-Alignment">Pointer Arithmetic and Alignment</a></li>
            <li><a id="toc-export" href="#export">@export</a></li>
            <li><a id="toc-bitSizeOf" href="#bitSizeOf">@bitSizeOf</a></li>
            <li><a id="toc-No-More-Capture-Aliasing" href="#No-More-Capture-Aliasing">No More Capture Aliasing</a></li>
            <li><a id="toc-noasync" href="#noasync">noasync</a></li>
            <li><a id="toc-Deprecated-Builtins-Removed" href="#Deprecated-Builtins-Removed">Deprecated Builtins Removed</a></li>
            <li><a id="toc-Allow-Empty-Inferred-Error-Sets" href="#Allow-Empty-Inferred-Error-Sets">Allow Empty Inferred Error Sets</a></li>
            <li><a id="toc-TypeOf-Supports-Multiple-Parameters" href="#TypeOf-Supports-Multiple-Parameters">@TypeOf Supports Multiple Parameters</a></li>
            <li><a id="toc-Underscore-Separators-in-Number-Literals" href="#Underscore-Separators-in-Number-Literals">Underscore Separators in Number Literals</a></li>
            <li><a id="toc-Slicing-with-Comptime-Indexes" href="#Slicing-with-Comptime-Indexes">Slicing with Comptime Indexes</a></li>
            <li><a id="toc-errdefer-Payload" href="#errdefer-Payload">errdefer Payload</a></li>
        </ul></li>
        <li><a id="toc-Standard-Library" href="#Standard-Library">Standard Library</a>
        <ul>
            <li><a id="toc-Async-IO" href="#Async-IO">Async I/O</a></li>
            <li><a id="toc-Debug-Info-and-Stack-Traces" href="#Debug-Info-and-Stack-Traces">Debug Info and Stack Traces</a></li>
            <li><a id="toc-Formatted-Printing" href="#Formatted-Printing">Formatted Printing</a></li>
            <li><a id="toc-IO-Streams" href="#IO-Streams">I/O Streams</a></li>
            <li><a id="toc-Filesystem" href="#Filesystem">Filesystem</a></li>
            <li><a id="toc-Networking" href="#Networking">Networking</a></li>
            <li><a id="toc-JSON" href="#JSON">JSON</a></li>
            <li><a id="toc-Bring-Your-Own-OS-Abstraction-Layer" href="#Bring-Your-Own-OS-Abstraction-Layer">Bring-Your-Own-OS Abstraction Layer</a></li>
            <li><a id="toc-ArrayList" href="#ArrayList">ArrayList</a></li>
            <li><a id="toc-Memory" href="#Memory">Memory</a></li>
            <li><a id="toc-Crypto" href="#Crypto">Crypto</a></li>
            <li><a id="toc-Start-Code" href="#Start-Code">Start Code</a></li>
        </ul></li>
        <li><a id="toc-Documentation" href="#Documentation">Documentation</a>
        <ul>
            <li><a id="toc-Documentation-Generation" href="#Documentation-Generation">Documentation Generation</a></li>
        </ul></li>
        <li><a id="toc-Safety" href="#Safety">Safety</a></li>
        <li><a id="toc-zig-build" href="#zig-build">zig build</a></li>
        <li><a id="toc-zig-fmt" href="#zig-fmt">zig fmt</a></li>
        <li><a id="toc-zig-cc" href="#zig-cc">zig cc</a></li>
        <li><a id="toc-libc" href="#libc">libc</a>
        <ul>
            <li><a id="toc-musl-120" href="#musl-120">musl 1.2.0</a></li>
            <li><a id="toc-glibc-231" href="#glibc-231">glibc 2.31</a></li>
            <li><a id="toc-mingw-w64-700" href="#mingw-w64-700">mingw-w64 7.0.0</a></li>
        </ul></li>
        <li><a id="toc-C-Translation" href="#C-Translation">C Translation</a></li>
        <li><a id="toc-Self-Hosted-Compiler-Progress" href="#Self-Hosted-Compiler-Progress">Self-Hosted Compiler Progress</a></li>
        <li><a id="toc-compiler-rt" href="#compiler-rt">compiler-rt</a></li>
        <li><a id="toc-Test-Coverage" href="#Test-Coverage">Test Coverage</a></li>
        <li><a id="toc-Memory-Usage-Reduction" href="#Memory-Usage-Reduction">Memory Usage Reduction</a></li>
        <li><a id="toc-Advanced-IR-Debugging" href="#Advanced-IR-Debugging">Advanced IR Debugging</a></li>
        <li><a id="toc-Command-Line-Interface" href="#Command-Line-Interface">Command Line Interface</a></li>
        <li><a id="toc-Miscellaneous-Improvements" href="#Miscellaneous-Improvements">Miscellaneous Improvements</a></li>
        <li><a id="toc-Bug-Fixes" href="#Bug-Fixes">Bug Fixes</a>
        <ul>
            <li><a id="toc-This-Release-Contains-Bugs" href="#This-Release-Contains-Bugs">This Release Contains Bugs</a></li>
        </ul></li>
        <li><a id="toc-Please-Welcome-Vexu-to-the-Core-Zig-Team" href="#Please-Welcome-Vexu-to-the-Core-Zig-Team">Please Welcome Vexu to the Core Zig Team</a></li>
        <li><a id="toc-Roadmap" href="#Roadmap">Roadmap</a>
        <ul>
            <li><a id="toc-Package-Manager-Status" href="#Package-Manager-Status">Package Manager Status</a></li>
            <li><a id="toc-C-Header-File-Generation-Status" href="#C-Header-File-Generation-Status">C Header File Generation Status</a></li>
            <li><a id="toc-Accepted-Proposals" href="#Accepted-Proposals">Accepted Proposals</a></li>
        </ul></li>
        <li><a id="toc-Active-Open-Source-Projects-Using-Zig" href="#Active-Open-Source-Projects-Using-Zig">Active Open-Source Projects Using Zig</a></li>
        <li><a id="toc-Funding-Status" href="#Funding-Status">Funding Status</a></li>
        <li><a id="toc-Thank-You-Sponsors" href="#Thank-You-Sponsors">Thank You Sponsors!</a></li>
    </ul>

    

    <h1 id="LLVM-10"><a href="#toc-LLVM-10">LLVM 10</a> <a class="hdr" href="#LLVM-10">ยง</a></h1>

    <p>
    This release of Zig upgrades to
    <a href="http://releases.llvm.org/10.0.0/docs/ReleaseNotes.html">LLVM 10</a>.
    Zig operates in lockstep with LLVM; Zig 0.6.0 is not compatible with LLVM 9.
    </p>
    <p>
    As far as Zig is concerned, the primary benefits of the new LLVM version are bug
    fixes, especially for <a href="#ARM-Support">ARM Support</a>, <a href="#MIPS-Support">MIPS Support</a>, and <a href="#RISC-V-Support">RISC-V Support</a>.
    </p>
    <p>
    This is the first release of <a href="https://lld.llvm.org/">LLD</a> that has all of Zig's patches
    merged upstream. Consequently, Zig's source repository no longer includes a fork of LLD sources.
    Amusingly, it also means that the source tarball
    <a href="https://ziglang.org/download/0.6.0/zig-0.6.0.tar.xz">zig-0.6.0.tar.xz</a>
    is 0.5 MiB smaller than
    <a href="https://ziglang.org/download/0.5.0/zig-0.5.0.tar.xz">zig-0.5.0.tar.xz</a>,
    since the deletion of LLD sources saved more space than all the rest of the changes made
    in this release cycle combined. Note that the new <a href="#Bootstrap-Tarball">Bootstrap Tarball</a>
    bundles all dependencies of the Zig compiler, which includes LLVM, LLD, and Clang.
    </p>
    <p>
    Thanks to LemonBoy for submitting patches to update Zig's codebase to LLVM 10, as well as
    submitting countless bug reports and patches upstream to LLVM and LLD, to get various
    cross-compiling issues sorted out.
    </p>
    

    <h1 id="Bootstrap-Tarball"><a href="#toc-Bootstrap-Tarball">Bootstrap Tarball</a> <a class="hdr" href="#Bootstrap-Tarball">ยง</a></h1>

    <p>With <a href="#zig-cc">zig cc</a> now available, the 0.6.0 release of Zig comes with a special new source tarball:
    <a href="https://ziglang.org/download/0.6.0/zig-bootstrap-0.6.0.tar.xz" style="white-space: nowrap">zig-bootstrap-0.6.0.tar.xz</a>
    </p>
    <p>
    This is made from the <a href="https://github.com/ziglang/bootstrap">ziglang/bootstrap</a>
    source repository, which contains unpatched LLVM, Clang, LLD, and Zig sources, and a
    <a href="https://github.com/ziglang/bootstrap/blob/0.6.0/build">simple build script with <strong>no branching logic</strong></a>.
    </p>
    <p>
    The purpose of the bootstrap tarball is to start with minimum system dependencies and end with
    a fully operational Zig compiler for any target. It does this in exactly 4 steps:
    </p>
    <ol>
      <li>Build LLVM, Clang, and LLD from source, for the native target, using the native C++ compiler.</li>
      <li>Build Zig from source for the native target, linking against LLVM, Clang, and LLD.</li>
      <li>Now we have Zig as a cross compiler. Use it to rebuild LLVM, Clang, and LLD for the specified target.</li>
      <li>Finally, use Zig to build itself, for the specified target.</li>
    </ol>
    <p>And thus, the <a href="https://github.com/ziglang/zig/issues/853">Grand Bootstrapping Plan</a>
    is fulfilled. The number of steps will always be these four, or less. Never more.</p>
    <p>
    This bootstrap process provides the five new binary builds available in this release, that were not
    available previously:
    </p>
    <ul>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv7a-0.6.0.tar.xz">zig-linux-armv7a-0.6.0.tar.xz</a> (32-bit <a href="#ARM-Support">ARM</a> Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-armv6kz-0.6.0.tar.xz">zig-linux-armv6kz-0.6.0.tar.xz</a> (older 32-bit ARM that notably works on Raspberry Pi 1 and RPi Zero)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-i386-0.6.0.tar.xz">zig-linux-i386-0.6.0.tar.xz</a> (<a href="#32-bit-x86-Support">32-bit x86</a> Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-linux-riscv64-0.6.0.tar.xz">zig-linux-riscv64-0.6.0.tar.xz</a> (<a href="#RISC-V-Support">RISC-V</a> Linux)</li>
      <li><a href="https://ziglang.org/download/0.6.0/zig-windows-i386-0.6.0.zip">zig-windows-i386-0.6.0.zip</a> (<a href="#32-bit-Windows-Support">32-bit x86 Windows</a>)</li>
    </ul>
    <p>
    See <a href="https://ziglang.org/download/">the download page</a> for a full list of
    tarballs.
    </p>
    <p>
    Thanks to Timon Kruiper and LemonBoy for contributions related to this.
    </p>
    

    <h1 id="Support-Table"><a href="#toc-Support-Table">Support Table</a> <a class="hdr" href="#Support-Table">ยง</a></h1>

    <p>
    Zig uses a <a href="#Tier-System">Tier System</a> to communicate the level of support for different targets. 
    Notably, in this release:
    </p>
<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>Linux 3.16+</th>
<th>macOS 10.13+</th>
<th>Windows 8.1+</th>
<th>FreeBSD 12.0+</th>
<th>NetBSD 8.0+</th>
<th>UEFI</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86_64</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td style="white-space: nowrap"><a href="#Tier-2-Support">Tier 2</a></td>
</tr>
<tr>
<td>arm64</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
</tr>
<tr>
<td>arm32</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
</tr>
<tr>
<td>mips32 LE</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>i386</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
</tr>
<tr>
<td>riscv64</td>
<td><a href="#Tier-1-Support">Tier 1</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
</tr>
<tr>
<td>bpf</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>hexagon</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>mips32 BE</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>mips64</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>amdgcn</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>sparc</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>s390x</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>lanai</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc32</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>powerpc64</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td>N/A</td>
</tr>
<tr>
<td>avr</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>riscv32</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
</tr>
<tr>
<td>xcore</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>nvptx</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>msp430</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>r600</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>arc</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>tce</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>le</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>amdil</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>hsail</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>spir</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>kalimba</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>shave</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
<tr>
<td>renderscript</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
<td>N/A</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td>N/A</td>
</tr>
</tbody>
</table>

    <h2 id="WebAssembly-Support"><a href="#toc-WebAssembly-Support">WebAssembly Support</a> <a class="hdr" href="#WebAssembly-Support">ยง</a></h2>

<table>
<thead>
<tr>
<th></th>
<th>free standing</th>
<th>emscripten</th>
<th>WASI</th>
</tr>
</thead>
<tbody>
<tr>
<td>wasm32</td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
<td><a href="#Tier-3-Support">Tier 3</a></td>
<td><a href="#Tier-2-Support">Tier 2</a></td>
</tr>
<tr>
<td>wasm64</td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
<td><a href="#Tier-4-Support">Tier 4</a></td>
</tr>
</tbody>
</table>
    
    <p>
    Thanks to Benjamin Feng and Colin Svingen's contributions:
    </p>
    <ul>
      <li>The WASI OS bits are audited and updated.</li>
      <li><code class="zig">std.heap.page_allocator</code> gains a WebAssembly implementation.</li>
    </ul>
    

    <h2 id="Tier-System"><a href="#toc-Tier-System">Tier System</a> <a class="hdr" href="#Tier-System">ยง</a></h2>


    <h3 id="Tier-1-Support"><a href="#toc-Tier-1-Support">Tier 1 Support</a> <a class="hdr" href="#Tier-1-Support">ยง</a></h3>

    <ul>
      <li>Not only can Zig generate machine code for these targets, but the standard
   library cross-platform abstractions have implementations for these targets.
   Thus it is practical to write a pure Zig application with no dependency on
   libc.</li>
      <li>The CI server automatically tests these targets on every commit to master
      branch, and updates <a href="https://ziglang.org/download/">the download page</a>
      with links to pre-built binaries.</li>
      <li>These targets have debug info capabilities and therefore produce stack traces
        on failed assertions.</li>
      <li>libc is available for this target even when cross compiling.</li>
      <li>All the behavior tests and applicable standard library tests pass for this target.
          All language features are known to work correctly.</li>
    </ul>
    

    <h3 id="Tier-2-Support"><a href="#toc-Tier-2-Support">Tier 2 Support</a> <a class="hdr" href="#Tier-2-Support">ยง</a></h3>

    <ul>
    <li>The standard library supports this target, but it's possible that some
      APIs will give an "Unsupported OS" compile error. One can link with libc or other
      libraries to fill in the gaps in the standard library.</li>
    <li>These targets are known to work, but may not be automatically tested, so there
      are occasional regressions.</li>
    <li>Some tests may be disabled for these targets as we work toward
      <a href="#Tier-1-Support">Tier 1 Support</a>.
    </li>
    </ul>
    

    <h3 id="Tier-3-Support"><a href="#toc-Tier-3-Support">Tier 3 Support</a> <a class="hdr" href="#Tier-3-Support">ยง</a></h3>

    <ul>
    <li>The standard library has little to no knowledge of the existence of this
        target.</li>
    <li>Because Zig is based on LLVM, it has the capability to build for these
      targets, and LLVM has the target enabled by default.</li>
    <li>These targets are not frequently tested; one will likely need to contribute
      to Zig in order to build for these targets.</li>
    <li>The Zig compiler might need to be updated with a few things such as<ul>
       <li>what sizes are the C integer types</li>
       <li>C ABI calling convention for this target</li>
       <li>bootstrap code and default panic handler</li>
     </ul>
     <li><code>zig targets</code> is guaranteed to include this target.</li>
    </ul>
    

    <h3 id="Tier-4-Support"><a href="#toc-Tier-4-Support">Tier 4 Support</a> <a class="hdr" href="#Tier-4-Support">ยง</a></h3>

    <ul>
      <li>Support for these targets is entirely experimental.</li>
      <li>LLVM may have the target as an experimental target, which means that you
   need to use Zig-provided binaries for the target to be available, or
   build LLVM from source with special configure flags. <code>zig targets</code> will
   display the target if it is available.</li>
   <li>This target may be considered deprecated by an official party,
     <a href="https://support.apple.com/en-us/HT208436">such as macosx/i386</a> in which
     case this target will remain forever stuck in Tier 4.</li>
   <li>This target may only support <code>--emit asm</code> and cannot emit object files.</li>
    </ul>
    
    

    <h2 id="Windows-Support"><a href="#toc-Windows-Support">Windows Support</a> <a class="hdr" href="#Windows-Support">ยง</a></h2>

    <p>
    Zig's Windows support improved considerably in this release. Counterintuitively,
    in the <a href="#Support-Table">Support Table</a>, x86_64-windows went from
    <a href="#Tier-1-Support">Tier 1</a> =&gt; <a href="#Tier-2-Support">Tier 2</a>,
    but this is due to more <a href="#SIMD">SIMD</a> test coverage added, and it was
    discovered that vectors of <code class="zig"><span class="tok-type">f16</span></code> are failing some behavior tests.
    This is the <a href="https://github.com/ziglang/zig/issues/4952">only issue</a>
    holding Windows (both 32-bit and 64-bit) back from <a href="#Tier-1-Support">Tier 1</a>.
    </p>
    <p>
    In this release, the minimum supported Windows version is bumped from 7+ to 8.1+, following the
    <a href="https://support.microsoft.com/en-us/help/13853/windows-lifecycle-fact-sheet">extended support lifecycle of Microsoft</a>.
    </p>
    <p>In addition:</p>
    <ul>
      <li>More cross compiling support for Windows system DLLs.</li>
      <li><code class="zig">wWinMain</code>, <code class="zig">wWinMainCRTStartup</code>,
        and <code class="zig">DllMain</code> are now recognized entrypoints. (#4376)</li>
      <li>Improved <a href="#Debug-Info-and-Stack-Traces">Debug Info and Stack Traces</a></li>
      <li>The hack to disable native <a href="#CPU-Features">CPU Features</a> on Windows is removed
          thanks to bug fixes in <a href="#LLVM-10">LLVM 10</a>. (#508)</li>
    </ul>
    <p>
    Thanks Jared Miller, emekoi, syscall0, and LemonBoy for contributions related to this.
    </p>

    <h3 id="32-bit-Windows-Support"><a href="#toc-32-bit-Windows-Support">32-bit Windows Support</a> <a class="hdr" href="#32-bit-Windows-Support">ยง</a></h3>

    <p>
    In this release, i386-windows goes from
    <a href="#Tier-3-Support">Tier 3</a> =&gt; <a href="#Tier-2-Support">Tier 2</a>.
    A <a href="#Bootstrap-Tarball">pre-made .zip build of 32-bit Windows</a> is newly available.
    </p>
    <p>
    Thanks to LemonBoy's work on this:
    </p>
    <ul>
      <li>Support for Win32 Thread-Local Storage.</li>
      <li>Adding more lib32 .def files from <a href="#mingw-w64-700">mingw-w64</a>.</li>
      <li>Removing x86/Windows name mangling hack and properly generating
        correct .lib files from mingw-w64 sources, by adding dlltool functionality to Zig.</li>
      <li>Adding <a href="#Test-Coverage">Test Coverage</a> for i386-windows.</li>
      <li>Fixing stack-probe symbol redefinition.</li>
    </ul>
    <p>
    The only thing holding 32-bit Windows back from <a href="#Tier-1-Support">Tier 1 Support</a> is enabling
    i386-windows CI builds of Zig that update the download page and the
    <a href="https://github.com/ziglang/zig/issues/4952">same f16 vector issue from 64-bit Windows</a>.
    </p>
    
    

    <h2 id="RISC-V-Support"><a href="#toc-RISC-V-Support">RISC-V Support</a> <a class="hdr" href="#RISC-V-Support">ยง</a></h2>

    <p>
    RISC-V support in Zig is now excellent! We even have
    riscv64 binary tarballs now thanks to the <a href="#Bootstrap-Tarball">Bootstrap Tarball</a>.
    It does, however require
    <a href="https://github.com/ziglang/bootstrap/issues/4#issuecomment-608549353">one workaround</a>
    due to
    <a href="https://bugs.llvm.org/show_bug.cgi?id=45419">clang crashing when it tries to build itself for self-hosted riscv64</a>.
    </p>
    <p>riscv64-freestanding went from
    <a href="#Tier-4-Support">Tier 4</a> =&gt; <a href="#Tier-1-Support">Tier 1</a>.
    </p>
    <p>riscv64-linux went from <a href="#Tier-4-Support">Tier 4</a> =&gt; <a href="#Tier-2-Support">Tier 2</a>
    and is already nearing <a href="#Tier-1-Support">Tier 1</a>.</p>
    <p>
    <a href="#Debug-Info-and-Stack-Traces">Debug Info and Stack Traces</a> on RISC-V is now working.
    </p>
    <p>
    The default ABI of riscv32-linux and riscv64-linux is changed to be 
    ilp32d and lp64d, respectively. Likewise, the default ABI of non-linux riscv32 and riscv64
    are changed to be ilp32 and lp64. This matches Clang's behavior. (#4863)
    </p>
    <p>
    Zig now has <a href="#Test-Coverage">Test Coverage</a> for riscv64 with no libc and riscv64 with
    <a href="#musl-120">musl</a> libc. The issue for Zig providing <a href="#glibc-231">glibc</a> for
    riscv64 is #3340.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this, and to Luรญs Marques for fixing
    RISC-V issues upstream, which landed in <a href="#LLVM-10">LLVM 10</a>.
    </p>
    

    <h2 id="ARM-Support"><a href="#toc-ARM-Support">ARM Support</a> <a class="hdr" href="#ARM-Support">ยง</a></h2>

    <p>
    aarch64-linux is very nearly <a href="#Tier-1-Support">Tier 1</a>. The only thing preventing it is
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+label%3Aarch-arm64+label%3Abug">some behavior tests are disabled</a>.
    </p>
    <p>
    In this release, Zig gained CI <a href="#Test-Coverage">Test Coverage</a> for aarch64, and the download page
    is updated with every master branch commit with a binary tarball for aarch64.
    </p>
    <p>
    Thanks to the <a href="#Bootstrap-Tarball">Bootstrap Tarball</a> this release additionally gains a
    32-bit ARM binary available (armv7a), as well as another 32-bit slightly older ARM
    binary (armv6kz) which notably works on Raspberry Pi 1 and RPi 0.
    </p>
    <p>
    Thank you to Timon Kruiper and LemonBoy for working together to solve undefined behavior
    bugs revealed by building Zig with <a href="#zig-cc">zig cc</a>.
    </p>
    <ul>
      <li>Fix signedness for some fields in ARM stat definition</li>
      <li>C ABI support is partially implemented.</li>
      <li>Fix possible unaligned ptr from <code>getauxval</code>. This caused SIGILL on armv7a-linux. (#4796)</li>
      <li>Fix multiplication overflow in <code>hash_const_val</code>. In some cases the compiler
        was actually emitting an 64 bit signed multiplication, instead of a 32 bit unsigned one.</li>
    </ul>
    

    <h2 id="32-bit-x86-Support"><a href="#toc-32-bit-x86-Support">32-bit x86 Support</a> <a class="hdr" href="#32-bit-x86-Support">ยง</a></h2>

    <p>
    i386-linux went from <a href="#Tier-3-Support">Tier 3</a> =&gt; <a href="#Tier-2-Support">Tier 2</a>,
    and is nearing <a href="#Tier-1-Support">Tier 1</a>.
    </p>
    <p>
    Thanks to the <a href="#Bootstrap-Tarball">Bootstrap Tarball</a> this release additionally gains a
    i386-linux binary available.
    </p>
    <p>Thanks LemonBoy for implementing i386 support during this cycle. (#3808, #4408)</p>
    

    <h2 id="MIPS-Support"><a href="#toc-MIPS-Support">MIPS Support</a> <a class="hdr" href="#MIPS-Support">ยง</a></h2>

    <p>LemonBoy contributed MIPS fixes:</p>
    <ul>
      <li>Correct signal bits for MIPS. Also enable the segfault handler for all the
        supported architectures beside MIPS.</li>
      <li>Fix pipe syscall for MIPS.</li>
      <li>Implement target_dynamic_linker for MIPS.</li>
    </ul>
    

    <h2 id="NetBSD-Support"><a href="#toc-NetBSD-Support">NetBSD Support</a> <a class="hdr" href="#NetBSD-Support">ยง</a></h2>

    <p>
    LemonBoy contributed NetBSD fixes: (#4793)
    </p>
    <ul>
      <li>Fixes some nasty errors in the threading code</li>
      <li>Makes Zig able to run all the tests (at least on x86-64) except the event ones</li>
      <li>Audits and corrects some defines for NetBSD</li>
    </ul>
    

    <h2 id="UEFI-Support"><a href="#toc-UEFI-Support">UEFI Support</a> <a class="hdr" href="#UEFI-Support">ยง</a></h2>

    <p>Nick Erdmann and Heppokoyuki contributed UEFI improvements:</p>
    <ul>
      <li>make the subsystem configurable in <a href="#zig-build">zig build</a></li>
      <li>fix con_in definition and add EFI_SIMPLE_TEXT_INPUT_PROTOCOL definition</li>
      <li>add file protocols and improvements</li>
      <li>add documentation</li>
      <li>loading images</li>
      <li>snp, mnp, ip6, and udp6 support</li>
      <li>protocol handling improvements</li>
      <li>boot services and runtime services improvements</li>
      <li>loaded image protocol improvements</li>
      <li>Add shell parameters protocol</li>
      <li>device path protocol improvements</li>
      <li>status reform</li>
    </ul>
    

    <h2 id="macOS-Support"><a href="#toc-macOS-Support">macOS Support</a> <a class="hdr" href="#macOS-Support">ยง</a></h2>

    <p>
    In this release, x86_64-macos went from 
    <a href="#Tier-1-Support">Tier 1</a> =&gt; <a href="#Tier-2-Support">Tier 2</a>,
    however, this is not because Zig dropped any kind of support for macOS, but rather because
    the bar for meeting <a href="#Tier-1-Support">Tier 1</a> requirements was raised,
    to include "libc is available for this target even when cross-compiling."
    </p>
    

    

    <h1 id="Target-Details"><a href="#toc-Target-Details">Target Details</a> <a class="hdr" href="#Target-Details">ยง</a></h1>

    <p>
    Zig's awareness of <a href="#CPU-Features">CPU model and features</a> as well as
    <a href="#OS-Version-Ranges">operating system versions</a> has broadened.
    </p>
    <p>
    The standard library now has two distinct concepts:
    <code class="zig">std.Target</code> and <code class="zig">std.zig.CrossTarget</code>.
    </p>
    <p>
    CrossTarget is what Zig's command line options get parsed into. It contains the concept
    of "native" and "default". Once this structure is populated, it can be <em>resolved</em>
    into a Target.
    </p>
    <p>
    A Target has all the information available; the CPU, OS, and ABI are all populated.
    As an example, a CrossTarget might be set to "native", and then when it is resolved,
    it turns into a Target which has the triple <code>riscv64-linux-musl</code>.
    </p>
    <p>
    <a href="#zig-build">zig build</a> scripts set the desired CrossTarget of a build artifact; the Zig
    code being compiled only has access to the resolved Target as <code class="zig">std.Target.current</code>.
    </p>
    <p>
    Zig now supports a more fine-grained sense of what is native and what is not.
    Some examples:
    </p>
    <p>This is now allowed:</p>
    <pre>-target native</pre>
    <p>Different OS but native CPU, default Windows C ABI:</p>
    <pre>-target native-windows</pre>
    <p>This could be useful for example when running in Wine.</p>
    
    <p>Different CPU but native OS, native C ABI.</p>
    <pre>-target x86_64-native -mcpu=skylake</pre>
    
    <p>Different C ABI but otherwise native target:</p>
    <pre>-target native-native-musl</pre>
    <pre>-target native-native-gnu</pre>

    <p>
    This is a <strong>breaking change</strong> to std lib APIs for checking the OS and CPU architecture. 
    To update from 0.5.0 to 0.6.0:
    </p>
    <p>
    <code class="zig">builtin.os</code> =&gt; <code class="zig">builtin.os.tag</code>
    </p>
    <p>
    <code class="zig">builtin.arch</code> =&gt; <code class="zig">builtin.cpu.arch</code>
    </p>
    <p><code class="zig">std.build.Builder.standardTargetOptions</code> is changed to accept its
    parameters as a struct with default values. It now has the ability to
    specify a whitelist of targets allowed, as well as the default target.
    Rather than two different ways of collecting the target, it's now always
    a string that is validated, and prints helpful diagnostics for invalid
    targets. This feature should now be actually useful, and contributions
    welcome to further improve the user experience.</p>
    <p><code class="zig">std.build.LibExeObjStep.setTheTarget</code> is removed.
    <code class="zig">std.build.LibExeObjStep.setTarget</code> is updated to take a CrossTarget
    parameter.</p>
    <p>
    <code class="zig">std.build.LibExeObjStep.setTargetGLibC</code> is removed. glibc versions are
    handled in the CrossTarget API and can be specified with the <code>-target</code>
    triple.
    </p>
    <p>
    <code class="zig">std.builtin.Version</code> gains a <code class="zig">format</code> method.
    </p>
    <p>Thanks to Timon Kruiper for contributions related to this.</p>

    <h2 id="CPU-Features"><a href="#toc-CPU-Features">CPU Features</a> <a class="hdr" href="#CPU-Features">ยง</a></h2>

    <p>
    Zig now has a database of CPU models and CPU features for every architecture.
    Now that <code>zig targets</code> is <a href="#Self-Hosted-Compiler-Progress">self-hosted</a>
    and outputs JSON, the easiest way to see this is to pipe <code>zig targets</code> into a JSON
    file and inspect it with a graphical JSON viewer, such as Firefox. 
    </p>
    <p>
    Here I will show you <code>zig targets | jq .native</code> on the laptop that I am typing
    these release notes on:
    </p>
    <pre><code>{
  "triple": "x86_64-linux.5.4.15...5.4.15-gnu.2.27",
  "cpu": {
    "arch": "x86_64",
    "name": "skylake",
    "features": [
      "64bit",
      "adx",
      "aes",
      "avx",
      "avx2",
      "bmi",
      "bmi2",
      "clflushopt",
      "cmov",
      "cx16",
      "cx8",
      "ermsb",
      "f16c",
      "false_deps_popcnt",
      "fast_gather",
      "fast_scalar_fsqrt",
      "fast_shld_rotate",
      "fast_variable_shuffle",
      "fast_vector_fsqrt",
      "fma",
      "fsgsbase",
      "fxsr",
      "idivq_to_divl",
      "invpcid",
      "lzcnt",
      "macrofusion",
      "merge_to_threeway_branch",
      "mmx",
      "movbe",
      "nopl",
      "pclmul",
      "popcnt",
      "prfchw",
      "rdrnd",
      "rdseed",
      "rtm",
      "sahf",
      "sgx",
      "slow_3ops_lea",
      "sse",
      "sse2",
      "sse3",
      "sse4_1",
      "sse4_2",
      "ssse3",
      "vzeroupper",
      "x87",
      "xsave",
      "xsavec",
      "xsaveopt",
      "xsaves"
    ]
  },
  "os": "linux",
  "abi": "gnu"
}</code></pre>
    <p>
    Here you can see the CPU model and set of CPU features Zig detected. The implementation
    of this is <strong>fully self-hosted</strong>. Although Zig properly informs LLVM about
    CPU features when it does code generation, the awareness of CPU features and detection of
    CPU features is all implemented in Zig code. Currently, only x86 CPU feature detection is
    implemented; Zig falls back to LLVM for detecting native CPU model and features on other
    architectures. <a href="https://github.com/ziglang/zig/issues/4591">Contributions welcome</a>!
    </p>
    <p>
    Zig now has the ability to parse CPU features as part of the target triple.
    </p>
    <p>Native architecture, OS, and ABI, but baseline CPU features:</p>
    <pre>-target native -mcpu=baseline</pre>
    <p>RISC-V 64-bit architecture, OS linux, default ABI, native CPU plus the rdpid feature, minus the sse3 feature:</p>
    <pre>-target riscv64-linux -mcpu=native+rdpid-sse3</pre>
    <p>Target the RPi Zero:</p>
    <pre>-target arm-linux-musleabi -mcpu=arm1176jzf_s</pre>
    <p>
    Now that it is possible to select what CPU features are enabled, freestanding no longer
    has SSE enabled by default.
    </p>
    <p>Thanks to Layne Gustafson for the initial exploration and implementation of
    this feature, and to alichay for the initial implementation of x86 CPU feature detection.
    </p>
    <p>Thanks to LemonBoy, Michael Dusan, and Noam Preil for related contributions.</p>
    

    <h2 id="Removal-of-Sub-Architecture"><a href="#toc-Removal-of-Sub-Architecture">Removal of Sub-Architecture</a> <a class="hdr" href="#Removal-of-Sub-Architecture">ยง</a></h2>

    <p>
    The whole point of Zig is to re-examine the premises of system programming, and
    rework abstractions that have shown to be less than ideal. Naturally, once Zig
    gained CPU feature awareness, it raised the question, <em>what is the purpose of
    sub-architectures?</em>
    </p>
    <p>
    As it turns out, the answer is "none". Sub-architectures are rendered redundant by
    the existence of CPU features, and so they no longer exist in Zig.
    </p>
    <p>
    This has the happy consequence of making <code class="zig">std.Target.Cpu.Arch</code>
    an enum rather than a tagged union.
    </p>
    <p>Rather than:</p>
    <pre>-target armv7a-linux-gnu</pre>
    <p>Now it is:</p>
    <pre>-target arm-linux-gnu</pre>
    <p><code>v7a</code> is considered baseline, so to target a different sub-architecture such as
    v6kz, it would look like:</p>
    <pre>-target arm-linux-gnu -mcpu=generic+v6kz</pre>
    

    <h2 id="OS-Version-Ranges"><a href="#toc-OS-Version-Ranges">OS Version Ranges</a> <a class="hdr" href="#OS-Version-Ranges">ยง</a></h2>

    <p>Operating System version ranges are now part of the target. This means that
    <code class="zig"><span class="tok-kw">comptime</span></code> code has access to exactly which version(s) of
    an OS are being targeted. You can see this by looking at the output of <code>zig builtin</code>,
    which displays the source code provided by <code class="zig">std.builtin</code>. Here's a snippet
    of the output on the computer I'm using to type release notes:</p>
    <pre><code class="zig"><span class="tok-comment">// ...</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> os = Os{
    .tag = .linux,
    .version_range = .{ .linux = .{
        .range = .{
            .min = .{
                .major = <span class="tok-number">5</span>,
                .minor = <span class="tok-number">4</span>,
                .patch = <span class="tok-number">15</span>,
            },
            .max = .{
                .major = <span class="tok-number">5</span>,
                .minor = <span class="tok-number">4</span>,
                .patch = <span class="tok-number">15</span>,
            },
        },
        .glibc = .{
            .major = <span class="tok-number">2</span>,
            .minor = <span class="tok-number">27</span>,
            .patch = <span class="tok-number">0</span>,
        },
    }},
};
<span class="tok-comment">// ...</span></code></pre>
    <p>Updated syntax for <code>-target</code> to take into account OS version ranges:</p>
    <pre><code># still valid. default version range
-target x86_64-windows-msvc

# minimum windows version: XP
# maximum windows version: 10
-target x86_64-windows.xp...win10-msvc

# minimum windows version: 7
# maximum windows version: latest
-target x86_64-windows.win7-msvc

# linux example
-target aarch64-linux.3.16...5.3.1-musl

# specifying glibc version
-target mipsel-linux.4.10-gnu.2.1</code></pre>
    <p>Here's what it will look like to populate a <code class="zig">CrossTarget</code>:</p>
    <pre><code>-        tc.target = tests.Target{
-            .Cross = .{
-                .arch = .x86_64,
-                .os = .linux,
-                .abi = .gnu,
-            },
+        tc.target = std.zig.CrossTarget{
+            .cpu_arch = .x86_64,
+            .os_tag = .linux,
+            .abi = .gnu,</code></pre>
    <p>Code that used <code class="zig">Target.parse</code> need not be updated.</p>
    <p>Checking for the OS when doing conditional compilation:</p>
    <pre><code>--- a/lib/std/build/run.zig
+++ b/lib/std/build/run.zig
@@ -82,7 +82,7 @@ pub const RunStep = struct {
 
         var key: []const u8 = undefined;
         var prev_path: ?[]const u8 = undefined;
-        if (builtin.os == .windows) {
+        if (builtin.os.tag == .windows) {
             key = "Path";
             prev_path = env_map.get(key);
             if (prev_path == null) {</code></pre>

    <p><code class="zig">std.Target.getStandardDynamicLinkerPath</code> is renamed to
    <code class="zig">std.Target.standardDynamicLinkerPath</code> and no longer requires an allocator.</p>

    <p>
    Zig's method of detecting the native system ABI and dynamic linker is now simple but portable:
    it inspects the dynamic linker path of its own executable. If statically linked, Zig looks at the
    dynamic linker path of <code>/usr/bin/env</code>, which is ubiquitous due to its use in shebang
    lines. Based on the dynamic linker file name, the ABI can be deduced. The same static Zig build
    will correctly detect the native ABI and dynamic linker path on Debian, NixOS, and Apline Linux,
    for example.
    </p>

     <p>No more <code class="zig">std.os.foo.is_the_target</code>.
     It had the downside of running all the comptime blocks and resolving
     all the usingnamespaces of each system, when just trying to discover if
     the current system is a particular one.
     For Darwin, where it's nice to use <code class="zig">std.Target.current.isDarwin()</code>, this
     demonstrates the utility that the proposal #425 would provide.
     </p>
     <p>
     This change allowed the removal of special Darwin OS version min handling. Now it is integrated
     with Zig's target OS range. The command line options
     <code>-mios-version-min</code> and <code>-mmacosx-version-min</code>
     are removed.
     </p>
     <p>
     Thanks LemonBoy for contributing OS version detection implementations for Windows and OSX.
     </p>
    

    

    <h1 id="Language-Changes"><a href="#toc-Language-Changes">Language Changes</a> <a class="hdr" href="#Language-Changes">ยง</a></h1>

    <ul>
      <li>Improved names of error sets when using merge error sets operator (<code class="zig">||</code>).</li>
      <li><code class="zig"><span class="tok-kw">pub</span></code> syntax for container fields is removed.</li>
      <li>Type coercion from <code class="zig">*[<span class="tok-number">0</span>]T</code> to <code class="zig">E![]<span class="tok-kw">const</span> T</code> is now allowed. This is an unambiguous, safe cast.</li>
      <li><code class="zig"><span class="tok-kw">asm</span></code> now accepts comptime-known values, rather than
        requiring string literal syntax.</li>
      <li>Removed compile error for peer result <code class="zig"><span class="tok-type">comptime_int</span></code> and
        <code class="zig"><span class="tok-null">null</span></code>. (#2763)</li>
      <li>Ability to pass <code class="zig"><span class="tok-kw">comptime</span></code> types and non <code class="zig"><span class="tok-kw">comptime</span></code> types to same parameter.</li>
      <li><code>@typeOf</code> is renamed to <code class="zig"><span class="tok-builtin">@TypeOf</span></code>. <a href="#zig-fmt">zig fmt</a> automatically performs the conversion, and the next release of Zig after this one will remove the automatic conversion.</li>
      <li>Ability to switch on pointer types. (#4074)</li>
      <li>Multiline strings in test and library names are disallowed.</li>
      <li>Zig language no longer requires the expression <code class="zig">a <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span></code> with
        <code class="zig"><span class="tok-kw">comptime</span></code> <code class="zig">a</code> to produce a
        <code class="zig"><span class="tok-kw">comptime</span></code> result.</li>
      <li>Timon Kruiper implemented casting between <code class="zig">[*c]T</code> and <code class="zig">?[*:<span class="tok-number">0</span>]T</code> on <code class="zig"><span class="tok-kw">fn</span></code> parameter. (#4176)</li>
      <li>Timon Kruiper improved <code class="zig"><span class="tok-builtin">@typeInfo</span></code> to lazily resolve declarations.
        This way all the declarations in a namespace won't be resolved until the user actually
        uses the declarations slice in the builtin TypeInfo union. (#2594, #3893, #4435)</li>
      <li><code class="zig"><span class="tok-builtin">@ptrCast</span></code> supports casting a slice to a pointer.</li>
      <li>LemonBoy implemented peer type resolution between <code class="zig">?[]T</code> and <code class="zig">*[N]T</code>. (#4767)</li>
      <li>There is now peer type resolution between mixed-const <code class="zig">[]T</code> and <code class="zig">*[N]T</code>. (#4766)</li>
    </ul>

    <p>
    Thanks to Vexu and LemonBoy for contributions related to the above list.
    </p>

    <h2 id="Type-Coercion-Syntax"><a href="#toc-Type-Coercion-Syntax">Type Coercion Syntax</a> <a class="hdr" href="#Type-Coercion-Syntax">ยง</a></h2>

    <p>
    <strong>Type coercion</strong> (previously called "implicit casting") is now
    performed with the <code class="zig"><span class="tok-builtin">@as</span></code> builtin, rather than by calling
    a type as a function. (#1757)
    </p>
    <p>
    While a bit more verbose, Zig now has the property that all function calls are
    always function calls and not type casts, and thus it is
    <strong>no longer required for
    someone reading Zig code to know the type to determine whether something is a
    type cast or a function call</strong>.
    </p>
    <p>Type coercion is now hooked up into the result location mechanism,
    and additionally hooked up with variable declarations, maintaining the property that:
    </p>
    <pre><code class="zig"><span class="tok-kw">var</span> a: T = b;</code></pre>
    <p>is semantically equivalent to:</p>
    <pre><code class="zig"><span class="tok-kw">var</span> a = <span class="tok-builtin">@as</span>(T, b);</code></pre>
    

    <h2 id="Sentinel-Terminated-Pointers"><a href="#toc-Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> <a class="hdr" href="#Sentinel-Terminated-Pointers">ยง</a></h2>

    <p>
    With this change, one feature was added to the language, and one feature was removed.
    </p>
    <p>
    There are no longer any C string literals such as <code>c"hello"</code>. Instead,
    the type of all string literals is changed from</p>
    <p><code class="zig">[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code></p>
    <p>to</p>
    <p><code class="zig">*<span class="tok-kw">const</span> [N:<span class="tok-number">0</span>]<span class="tok-type">u8</span></code></p>
    <p>Where N is the number of bytes in the string literal.</p>
    <p>
    Let's unpack that. Reading the type from left-to-right, this is a
    <strong>reference, immutable-memory, array of N items, followed by an element with value <code class="zig"><span class="tok-number">0</span></code>, element type <code class="zig"><span class="tok-type">u8</span></code></strong>.
    </p>
    <p>
    Note that the sentinel value is <em>not counted in the length</em>.
    </p>
    <p>
    This type has the length encoded in multiple ways. This means that it can automatically
    coerce to both <code class="zig">[]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> (because the length is encoded in the type),
    and it can also automatically coerce to <code class="zig">[*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span></code> (because both types
    are null-terminated).
    </p>
    <p>
    So, Zig string literals now can be passed directly to C functions which accept null-terminated
    strings, and they can also be passed directly to Zig functions which accept slices.
    </p>
    <p class="file">sentinel_ptrs.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    do_it_the_zig_way(<span class="tok-str">&quot;world&quot;</span>);
    do_it_the_c_way(<span class="tok-str">&quot;world&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">do_it_the_zig_way</span>(arg: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    std.debug.warn(<span class="tok-str">&quot;hello {}\n&quot;</span>, .{arg});
}

<span class="tok-kw">fn</span> <span class="tok-fn">do_it_the_c_way</span>(arg: [*:<span class="tok-number">0</span>]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {
    _ = std.c.printf(<span class="tok-str">&quot;hello %s\n&quot;</span>, arg);
}</code></pre><pre><code class="shell">$ zig build-exe sentinel_ptrs.zig -lc
$ ./sentinel_ptrs
hello world
hello world
</code></pre>

    <p>
    Additionally, slicing syntax now supports a way to assert that a sentinel exists at a particular
    element:
    </p>
    <p class="file">slice_sentinel.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;slice with sentinel&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span>, <span class="tok-str">'d'</span>, <span class="tok-str">'e'</span> };
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">1</span>..<span class="tok-number">3</span> :<span class="tok-str">'d'</span>];
    <span class="tok-kw">const</span> result = foo(slice);
    std.testing.expect(result == <span class="tok-str">'b'</span> + <span class="tok-str">'c'</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>(s: [*:<span class="tok-str">'d'</span>]<span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">var</span> index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">while</span> (s[index] != <span class="tok-str">'d'</span>) : (index += <span class="tok-number">1</span>) {
        sum += s[index];
    }
    <span class="tok-kw">return</span> sum;
}</code></pre><pre><code class="shell">$ zig test slice_sentinel.zig
1/1 test &quot;slice with sentinel&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    If the sentinel is incorrect, a safety check is activated:
    </p>
    <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;slice with sentinel&quot;</span> {
    <span class="tok-kw">var</span> array = [_]<span class="tok-type">i32</span>{ <span class="tok-str">'a'</span>, <span class="tok-str">'b'</span>, <span class="tok-str">'c'</span>, <span class="tok-str">'d'</span>, <span class="tok-str">'e'</span> };
    <span class="tok-kw">const</span> slice = array[<span class="tok-number">1</span>..<span class="tok-number">3</span> :<span class="tok-str">'f'</span>];
}</code></pre><pre><code class="shell">$ zig test test.zig
1/1 test &quot;slice with sentinel&quot;...sentinel mismatch
<span class="t37_1">/home/andy/dev/www.ziglang.org/docgen_tmp/test.zig:3:24</span>: <span class="t2_0">0x204c07 in test &quot;slice with sentinel&quot; (test)</span>
    const slice = array[1..3 :'f'];
                       <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/special/test_runner.zig:47:28</span>: <span class="t2_0">0x22bb2e in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/start.zig:253:37</span>: <span class="t2_0">0x20565d in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/start.zig:123:5</span>: <span class="t2_0">0x20539f in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/www.ziglang.org/docgen_tmp/test
</code></pre>

    <p>
    Thanks to LemonBoy, Raul Leal, daurnimator, and Michael Dusan for contributions
    related to this feature.
    </p>
    

    <h2 id="Remove-Array-to-Reference-Type-Coercion"><a href="#toc-Remove-Array-to-Reference-Type-Coercion">Remove Array-to-Reference Type Coercion</a> <a class="hdr" href="#Remove-Array-to-Reference-Type-Coercion">ยง</a></h2>

    <p>
    Now that <a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a> is done, the main motivation for type coercion
    from array values to slices is gone. It's a footgun for Zig to automatically convert a value
    into a pointer to that value; such an operation should be explicit.
    </p>
    <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;coerce array value to slice&quot;</span> {
    <span class="tok-kw">var</span> array: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
}</code></pre><pre><code class="shell">$ zig test test.zig
<span class="t0_1">./docgen_tmp/test.zig:2:36: </span><span class="t31_1">error: </span><span class="t0_1">array literal requires address-of operator to coerce to slice type '[]const i32'</span>
    var array: []const i32 = [_]i32{ 1, 2, 3, 4 };
                                   <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/test.zig:2:38: </span><span class="t36_1">note: </span><span class="t0_1">referenced here</span>
    var array: []const i32 = [_]i32{ 1, 2, 3, 4 };
                                     <span class="t32_1">^</span>
</code></pre>

    <p>
    How to upgrade code for these new semantics:
    </p>
    <p class="file">coerce_array_ptr.zig</p><pre><code class="zig"><span class="tok-kw">test</span> <span class="tok-str">&quot;coerce array pointer to slice&quot;</span> {
    <span class="tok-kw">var</span> array: []<span class="tok-kw">const</span> <span class="tok-type">i32</span> = &amp;[_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span> };
}</code></pre><pre><code class="shell">$ zig test coerce_array_ptr.zig
1/1 test &quot;coerce array pointer to slice&quot;...OK
All 1 tests passed.
</code></pre>

    <p>This change to simplifies the result location semantics, which helps with reasoning about
    Zig code, as well as reducing the complexity of a Zig compiler.</p>
    

    <h2 id="Numerical-Comparisons"><a href="#toc-Numerical-Comparisons">Numerical Comparisons</a> <a class="hdr" href="#Numerical-Comparisons">ยง</a></h2>

    <p>
    All numerical comparisons are now allowed no matter the type combinations.
    For example, small signed integers can be compared against large unsigned integers,
    and floats can be compared against integers.
    </p>
    <p>
    For a demonstration of this, you can look at the new <code class="zig">std.math.compare</code>
    function added to the <a href="#Standard-Library">Standard Library</a> and the test cases for it:
    </p>
    <p class="file">compare.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-comment">/// See also `Order`.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">const</span> CompareOperator = <span class="tok-kw">enum</span> {
    <span class="tok-comment">/// Less than (`&lt;`)</span>
    lt,

    <span class="tok-comment">/// Less than or equal (`&lt;=`)</span>
    lte,

    <span class="tok-comment">/// Equal (`==`)</span>
    eq,

    <span class="tok-comment">/// Greater than or equal (`&gt;=`)</span>
    gte,

    <span class="tok-comment">/// Greater than (`&gt;`)</span>
    gt,

    <span class="tok-comment">/// Not equal (`!=`)</span>
    neq,
};

<span class="tok-comment">/// This function does the same thing as comparison operators, however the</span>
<span class="tok-comment">/// operator is a runtime-known enum value. Works on any operands that</span>
<span class="tok-comment">/// support comparison operators.</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">compare</span>(a: <span class="tok-kw">var</span>, op: CompareOperator, b: <span class="tok-kw">var</span>) <span class="tok-type">bool</span> {
    <span class="tok-kw">return</span> <span class="tok-kw">switch</span> (op) {
        .lt =&gt; a &lt; b,
        .lte =&gt; a &lt;= b,
        .eq =&gt; a == b,
        .neq =&gt; a != b,
        .gt =&gt; a &gt; b,
        .gte =&gt; a &gt;= b,
    };
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;compare between signed and unsigned&quot;</span> {
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>), .lt, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, <span class="tok-number">2</span>), .gt, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>), .gte, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>), .gt, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>), .lte, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>), .lt, <span class="tok-builtin">@as</span>(<span class="tok-type">u9</span>, <span class="tok-number">255</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>), .gte, <span class="tok-builtin">@as</span>(<span class="tok-type">u9</span>, <span class="tok-number">255</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u9</span>, <span class="tok-number">255</span>), .gt, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u9</span>, <span class="tok-number">255</span>), .lte, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i9</span>, -<span class="tok-number">1</span>), .lt, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">i9</span>, -<span class="tok-number">1</span>), .gte, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>), .gt, <span class="tok-builtin">@as</span>(<span class="tok-type">i9</span>, -<span class="tok-number">1</span>)));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>), .lte, <span class="tok-builtin">@as</span>(<span class="tok-type">i9</span>, -<span class="tok-number">1</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), .lt, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">2</span>)));
    expect(<span class="tok-builtin">@bitCast</span>(<span class="tok-type">u8</span>, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)) == <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>));
    expect(!compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">255</span>), .eq, <span class="tok-builtin">@as</span>(<span class="tok-type">i8</span>, -<span class="tok-number">1</span>)));
    expect(compare(<span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>), .eq, <span class="tok-builtin">@as</span>(<span class="tok-type">u8</span>, <span class="tok-number">1</span>)));
}</code></pre><pre><code class="shell">$ zig test compare.zig
1/1 test &quot;compare between signed and unsigned&quot;...OK
All 1 tests passed.
</code></pre>

    <p>Thanks to Shawn Landden for the proposal.</p>
    

    <h2 id="Anonymous-Struct-Literals"><a href="#toc-Anonymous-Struct-Literals">Anonymous Struct Literals</a> <a class="hdr" href="#Anonymous-Struct-Literals">ยง</a></h2>

      <p>
      Zig now allows omitting the struct type of a literal. When the result is
      <a href="#Type-Coercion-Syntax">coerced</a>,
      the struct literal will directly instantiate the result location, with no copy:
      </p>
      <p class="file">struct_result.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous struct literal&quot;</span> {
    checkPoint(.{
        .x = <span class="tok-number">13</span>,
        .y = <span class="tok-number">67</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">checkPoint</span>(pt: <span class="tok-kw">struct</span> {x: <span class="tok-type">i32</span>, y: <span class="tok-type">i32</span>}) <span class="tok-type">void</span> {
    expect(pt.x == <span class="tok-number">13</span>);
    expect(pt.y == <span class="tok-number">67</span>);
}</code></pre><pre><code class="shell">$ zig test struct_result.zig
1/1 test &quot;anonymous struct literal&quot;...OK
All 1 tests passed.
</code></pre>

      <p>
      The struct type can be inferred. Here the result location does not include a type, and
      so Zig infers the type:
      </p>
      <p class="file">struct_anon.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fully anonymous struct&quot;</span> {
    dump(.{
        .int = <span class="tok-number">1234</span>,
        .float = <span class="tok-number">12.34</span>,
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">&quot;hi&quot;</span>,
    });
}

<span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(args: <span class="tok-kw">var</span>) <span class="tok-type">void</span> {
    expect(args.int == <span class="tok-number">1234</span>);
    expect(args.float == <span class="tok-number">12.34</span>);
    expect(args.b);
    expect(args.s[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    expect(args.s[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre><pre><code class="shell">$ zig test struct_anon.zig
1/1 test &quot;fully anonymous struct&quot;...OK
All 1 tests passed.
</code></pre>


      <p>This syntax can also be used to initialize unions without specifying the type:</p>
      <p class="file">anon_union.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">const</span> Number = <span class="tok-kw">union</span> {
    int: <span class="tok-type">i32</span>,
    float: <span class="tok-type">f64</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;anonymous union literal syntax&quot;</span> {
    <span class="tok-kw">var</span> i: Number = .{.int = <span class="tok-number">42</span>};
    <span class="tok-kw">var</span> f = makeNumber();
    expect(i.int == <span class="tok-number">42</span>);
    expect(f.float == <span class="tok-number">12.34</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">makeNumber</span>() Number {
    <span class="tok-kw">return</span> .{.float = <span class="tok-number">12.34</span>};
}</code></pre><pre><code class="shell">$ zig test anon_union.zig
1/1 test &quot;anonymous union literal syntax&quot;...OK
All 1 tests passed.
</code></pre>


    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for
    contributing fixes related to this feature.</p>
    

    <h2 id="Tuples-Added-Var-Args-Removed"><a href="#toc-Tuples-Added-Var-Args-Removed">Tuples Added, Var Args Removed</a> <a class="hdr" href="#Tuples-Added-Var-Args-Removed">ยง</a></h2>

    <p>Similar to
    <a href="https://ziglang.org/documentation/0.6.0/#Enum-Literals">Anonymous Enum Literals</a>
    and <a href="#Anonymous-Struct-Literals">Anonymous Struct Literals</a>, the type can be omitted from array literals.
    In this example, tuple syntax directly populates the array elements:</p>
      <p class="file">tuple.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;tuple syntax&quot;</span> {
    <span class="tok-kw">var</span> array: [<span class="tok-number">4</span>]<span class="tok-type">u8</span> = .{<span class="tok-number">11</span>, <span class="tok-number">22</span>, <span class="tok-number">33</span>, <span class="tok-number">44</span>};
    expect(array[<span class="tok-number">0</span>] == <span class="tok-number">11</span>);
    expect(array[<span class="tok-number">1</span>] == <span class="tok-number">22</span>);
    expect(array[<span class="tok-number">2</span>] == <span class="tok-number">33</span>);
    expect(array[<span class="tok-number">3</span>] == <span class="tok-number">44</span>);
}</code></pre><pre><code class="shell">$ zig test tuple.zig
1/1 test &quot;tuple syntax&quot;...OK
All 1 tests passed.
</code></pre>

      <p>
      A tuple is a <code class="zig"><span class="tok-kw">struct</span></code> with auto-numbered field names:
      </p>
      <p class="file">infer_tuple.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;fully anonymous tuple&quot;</span> {
    dump(.{ <span class="tok-builtin">@as</span>(<span class="tok-type">u32</span>, <span class="tok-number">1234</span>), <span class="tok-builtin">@as</span>(<span class="tok-type">f64</span>, <span class="tok-number">12.34</span>), <span class="tok-null">true</span>, <span class="tok-str">&quot;hi&quot;</span>});
}

<span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(args: <span class="tok-kw">var</span>) <span class="tok-type">void</span> {
    expect(args.@&quot;0&quot; == <span class="tok-number">1234</span>);
    expect(args.@&quot;1&quot; == <span class="tok-number">12.34</span>);
    expect(args.@&quot;2&quot;);
    expect(args.@&quot;3&quot;[<span class="tok-number">0</span>] == <span class="tok-str">'h'</span>);
    expect(args.@&quot;3&quot;[<span class="tok-number">1</span>] == <span class="tok-str">'i'</span>);
}</code></pre><pre><code class="shell">$ zig test infer_tuple.zig
1/1 test &quot;fully anonymous tuple&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    However, the <code class="zig">@&quot;&quot;</code> syntax is not needed, because
    although tuples are structs, they also have array-like qualities:
    </p>
    <p class="file">tuples_are_array_like.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;tuples support element access and .len field&quot;</span> {
    <span class="tok-kw">var</span> x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>;
    <span class="tok-kw">var</span> y: <span class="tok-type">i32</span> = <span class="tok-number">4567</span>;
    <span class="tok-kw">var</span> tup = .{ x, y };
    tup[<span class="tok-number">0</span>] += <span class="tok-number">1</span>; <span class="tok-comment">// works as long as the indexes are comptime-known</span>
    tup[<span class="tok-number">1</span>] -= <span class="tok-number">1</span>;

    expect(tup[<span class="tok-number">0</span>] == <span class="tok-number">1235</span>);
    expect(tup[<span class="tok-number">1</span>] == <span class="tok-number">4566</span>);

    <span class="tok-comment">// now we iterate over the fields</span>
    <span class="tok-kw">var</span> sum: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> index = <span class="tok-number">0</span>;
    <span class="tok-kw">inline</span> <span class="tok-kw">while</span> (index &lt; tup.len) : (index += <span class="tok-number">1</span>) {
        sum += tup[index];
    }
    expect(sum == <span class="tok-number">1235</span> + <span class="tok-number">4566</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;tuple concatenation&quot;</span> {
    <span class="tok-kw">var</span> one = .{ <span class="tok-str">&quot;hi&quot;</span>, <span class="tok-null">true</span> };
    <span class="tok-kw">var</span> two = .{ <span class="tok-number">12.34</span>, .ok };
    <span class="tok-kw">var</span> combined = one ++ two;

    expect(combined[<span class="tok-number">3</span>] == .ok);
}</code></pre><pre><code class="shell">$ zig test tuples_are_array_like.zig
1/2 test &quot;tuples support element access and .len field&quot;...OK
2/2 test &quot;tuple concatenation&quot;...OK
All 2 tests passed.
</code></pre>

    <p>
    Zig is determined to remain a small language.
    With the addition of tuples comes the removal of variadic parameter functions (#208).
    Printing and formatting are no exception. Formatted printing now uses tuples
    for the parameters to print, rather than var args:
    </p>
    <p class="file">hello.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    std.debug.warn(<span class="tok-str">&quot;Hello, {}\n&quot;</span>, .{<span class="tok-str">&quot;World!&quot;</span>});
}</code></pre><pre><code class="shell">$ zig build-exe hello.zig
$ ./hello
Hello, World!
</code></pre>

    <p>
    Note: Zig still supports C ABI functions with var args. Nothing is changed there.
    </p>
    <p>
    Zig's var args design was flawed, with many issues such as
    <a href="https://github.com/ziglang/zig/issues/557">var args can't handle void or number literal arguments</a>. With tuples, these issues are resolved.
    Zig's Tuples are much more robust and generally useful than its var args ever was.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4335">It is planned to add tuple type declaration syntax</a>.
    </p>
    <p>Thanks to Vexu, LemonBoy, dbandstra, and Alexander Naskos for fixes related to this feature.</p>
    

    <h2 id="SIMD"><a href="#toc-SIMD">SIMD</a> <a class="hdr" href="#SIMD">ยง</a></h2>

    <p>
    Zig's SIMD support in 0.6.0 is still far from complete, but significant progress has been made.
    </p>
    <p>
    Vectors gain element access syntax (#3575, #3580).
    This introduces the concept of vector index being part of a pointer
    type. This avoids vectors having well-defined in-memory layout, and
    allows vectors of any integer bit width to work the same way.
    </p>
    <p>
    When a vector is indexed with a scalar, this is vector element access,
    which is implemented in 0.6.0. When a vector is indexed with a vector,
    this is gather/scatter, which is not available in this release.
    </p>
    <p class="file">vector_elem.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector element access&quot;</span> {
    <span class="tok-kw">var</span> v: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>) = [_]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">5</span>, <span class="tok-number">3</span>, <span class="tok-null">undefined</span> };

    v[<span class="tok-number">2</span>] = <span class="tok-number">42</span>;
    expect(v[<span class="tok-number">1</span>] == <span class="tok-number">5</span>);
    v[<span class="tok-number">3</span>] = -<span class="tok-number">364</span>;
    expect(v[<span class="tok-number">2</span>] == <span class="tok-number">42</span>);
    expect(-<span class="tok-number">364</span> == v[<span class="tok-number">3</span>]);

    storev(&amp;v[<span class="tok-number">0</span>], <span class="tok-number">100</span>);
    expect(v[<span class="tok-number">0</span>] == <span class="tok-number">100</span>);
}
<span class="tok-kw">fn</span> <span class="tok-fn">storev</span>(ptr: <span class="tok-kw">var</span>, x: <span class="tok-type">i32</span>) <span class="tok-type">void</span> {
    ptr.* = x;
}</code></pre><pre><code class="shell">$ zig test vector_elem.zig
1/1 test &quot;vector element access&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Vectors now support comparisons, which returns a vector of <code class="zig"><span class="tok-type">bool</span></code>:
    </p>
    <p class="file">vector_cmp.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;
<span class="tok-kw">const</span> mem = std.mem;

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector comparisons&quot;</span> {
    <span class="tok-kw">var</span> v: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>) = [<span class="tok-number">4</span>]<span class="tok-type">i32</span>{ <span class="tok-number">2147483647</span>, -<span class="tok-number">2</span>, <span class="tok-number">30</span>, <span class="tok-number">40</span> };
    <span class="tok-kw">var</span> x: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i32</span>) = [<span class="tok-number">4</span>]<span class="tok-type">i32</span>{ <span class="tok-number">1</span>, <span class="tok-number">2147483647</span>, <span class="tok-number">30</span>, <span class="tok-number">4</span> };
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v == x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">false</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span> }));
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v != x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">true</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span> }));
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v &lt; x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">false</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">false</span> }));
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v &gt; x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span> }));
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v &lt;= x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">false</span>, <span class="tok-null">true</span>, <span class="tok-null">true</span>, <span class="tok-null">false</span> }));
    expect(mem.eql(<span class="tok-type">bool</span>, &amp;<span class="tok-builtin">@as</span>([<span class="tok-number">4</span>]<span class="tok-type">bool</span>, v &gt;= x), &amp;[<span class="tok-number">4</span>]<span class="tok-type">bool</span>{ <span class="tok-null">true</span>, <span class="tok-null">false</span>, <span class="tok-null">true</span>, <span class="tok-null">true</span> }));
}</code></pre><pre><code class="shell">$ zig test vector_cmp.zig
1/1 test &quot;vector comparisons&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Floating-point vector operations were broken; now they are fixed and no
    longer require a type parameter (#4027).
    </p>
    <p>
    Vector division is now supported, including with runtime-safety checks for integer overflow (#4737):
    </p>
    <p class="file">test.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;vector division safety&quot;</span> {
    <span class="tok-kw">var</span> a: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i16</span>) = [_]<span class="tok-type">i16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, -<span class="tok-number">32768</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">var</span> b: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i16</span>) = [_]<span class="tok-type">i16</span>{ <span class="tok-number">1</span>, <span class="tok-number">2</span>, -<span class="tok-number">1</span>, <span class="tok-number">4</span> };
    <span class="tok-kw">const</span> x = div(a, b);
    <span class="tok-kw">if</span> (x[<span class="tok-number">2</span>] == <span class="tok-number">32767</span>) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.Whatever;
}
<span class="tok-kw">fn</span> <span class="tok-fn">div</span>(a: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i16</span>), b: <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i16</span>)) <span class="tok-builtin">@Vector</span>(<span class="tok-number">4</span>, <span class="tok-type">i16</span>) {
    <span class="tok-kw">return</span> <span class="tok-builtin">@divTrunc</span>(a, b);
}</code></pre><pre><code class="shell">$ zig test test.zig
1/1 test &quot;vector division safety&quot;...integer overflow
<span class="t37_1">/home/andy/dev/www.ziglang.org/docgen_tmp/test.zig:10:12</span>: <span class="t2_0">0x2053be in div (test)</span>
    return @divTrunc(a, b);
           <span class="t32_1">^</span>
<span class="t37_1">/home/andy/dev/www.ziglang.org/docgen_tmp/test.zig:6:18</span>: <span class="t2_0">0x204bd6 in test &quot;vector division safety&quot; (test)</span>
    const x = div(a, b);
                 <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/special/test_runner.zig:47:28</span>: <span class="t2_0">0x22bc4e in std.special.main (test)</span>
        } else test_fn.func();
                           <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/start.zig:253:37</span>: <span class="t2_0">0x2057cd in std.start.posixCallMainAndExit (test)</span>
            const result = root.main() catch |err| {
                                    <span class="t32_1">^</span>
<span class="t37_1">/home/andy/Downloads/zig/lib/std/start.zig:123:5</span>: <span class="t2_0">0x20550f in std.start._start (test)</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>

Tests failed. Use the following command to reproduce the failure:
/home/andy/dev/www.ziglang.org/docgen_tmp/test
</code></pre>

    <p>See #903 for more details.</p>
    <p>
    Thanks to Shawn Landden, data-man, and LemonBoy for contributions related to SIMD.
    </p>
    

    <h2 id="newStackCall-Removed"><a href="#toc-newStackCall-Removed">@newStackCall Removed</a> <a class="hdr" href="#newStackCall-Removed">ยง</a></h2>

    <p>
    The original purpose of <code class="zig"><span class="tok-builtin">@newStackCall</span></code> was as an exploration
    for <a href="https://github.com/ziglang/zig/issues/1006">safe recursion</a>, but
    now the plan for safe recursion is via async functions.
    </p>
    <p>
    This plus the fact that this builtin had
    <a href="https://github.com/ziglang/zig/issues/3268">serious flaws</a>,
    it is now removed from the language.
    </p>
    <p>
    Whether this builtin will be revived before Zig 1.0 or permanently gone is yet
    to be determined. To update to Zig 0.6.0, users of this builtin will have to
    resort to inline assembly.
    </p>
    

    <h2 id="call"><a href="#toc-call">@call</a> <a class="hdr" href="#call">ยง</a></h2>

      <pre><code class="zig"><span class="tok-builtin">@call</span>(options: std.builtin.CallOptions, function: <span class="tok-kw">var</span>, args: <span class="tok-kw">var</span>) <span class="tok-kw">var</span></code></pre>
      <p>
      This new builtin calls a function, in the same way that invoking an expression with
      parentheses does, except the parameters are a <a href="#Tuples-Added-Var-Args-Removed">tuple</a>:
      </p>
      <p class="file">call.zig</p><pre><code class="zig"><span class="tok-kw">const</span> assert = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>).debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;noinline function call&quot;</span> {
    assert(<span class="tok-builtin">@call</span>(.{}, add, .{<span class="tok-number">3</span>, <span class="tok-number">9</span>}) == <span class="tok-number">12</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">return</span> a + b;
}</code></pre><pre><code class="shell">$ zig test call.zig
1/1 test &quot;noinline function call&quot;...OK
All 1 tests passed.
</code></pre>

      <p>
      <code class="zig"><span class="tok-builtin">@call</span></code> allows more flexibility than normal function call syntax does. The
      <code class="zig">CallOptions</code> struct is reproduced here:
      </p>
      <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallOptions = <span class="tok-kw">struct</span> {
    modifier: Modifier = .auto,

    <span class="tok-comment">/// Only valid when `Modifier` is `Modifier.async_kw`.</span>
    stack: ?[]<span class="tok-kw">align</span>(std.Target.stack_align) <span class="tok-type">u8</span> = <span class="tok-null">null</span>,

    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> Modifier = <span class="tok-kw">enum</span> {
        <span class="tok-comment">/// Equivalent to function call syntax.</span>
        auto,

        <span class="tok-comment">/// Equivalent to async keyword used with function call syntax.</span>
        async_kw,

        <span class="tok-comment">/// Prevents tail call optimization. This guarantees that the return</span>
        <span class="tok-comment">/// address will point to the callsite, as opposed to the callsite's</span>
        <span class="tok-comment">/// callsite. If the call is otherwise required to be tail-called</span>
        <span class="tok-comment">/// or inlined, a compile error is emitted instead.</span>
        never_tail,

        <span class="tok-comment">/// Guarantees that the call will not be inlined. If the call is</span>
        <span class="tok-comment">/// otherwise required to be inlined, a compile error is emitted instead.</span>
        never_inline,

        <span class="tok-comment">/// Asserts that the function call will not suspend. This allows a</span>
        <span class="tok-comment">/// non-async function to call an async function.</span>
        no_async,

        <span class="tok-comment">/// Guarantees that the call will be generated with tail call optimization.</span>
        <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
        always_tail,

        <span class="tok-comment">/// Guarantees that the call will inlined at the callsite.</span>
        <span class="tok-comment">/// If this is not possible, a compile error is emitted instead.</span>
        always_inline,

        <span class="tok-comment">/// Evaluates the call at compile-time. If the call cannot be completed at</span>
        <span class="tok-comment">/// compile-time, a compile error is emitted instead.</span>
        compile_time,
    };
};</code></pre>
      <p>
      The builtins <code>@noInlineCall</code> and <code>@inlineCall</code> are removed;
      instead <code class="zig"><span class="tok-builtin">@call</span></code> supports <code class="zig">.modifier = .never_inline</code>,
      and <code class="zig">.modifier = .always_inline</code>.
      </p>
      <p>
      Additionally, the <code class="zig">.never_tail</code> and <code class="zig">.always_tail</code>
      modifiers are available (#3732). These are still experimental; proper compile errors are
      not implemented to detect when these modifiers are used incorrectly.
      </p>
      <p>
      For an explanation of <code class="zig">.no_async</code>, see <a href="#noasync">noasync</a>.
      </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    

    <h2 id="callconv"><a href="#toc-callconv">callconv</a> <a class="hdr" href="#callconv">ยง</a></h2>

    <p>
    Old syntax for a function that has the C calling convention:
    </p>
    <pre><code class="zig"><span class="tok-kw">extern</span> <span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">void</span> {}</code></pre>
    <p>
    New syntax:
    </p>
    <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-kw">callconv</span>(.C) <span class="tok-type">void</span> {}</code></pre>
    <p>
    In Zig 0.6.0, <a href="#zig-fmt">zig fmt</a> automatically transforms the old syntax to the new syntax.
    In Zig 0.7.0, it will no longer do that.
    </p>
    <p>
    Similarly the keywords <code class="zig"><span class="tok-kw">stdcallcc</span></code> and <code class="zig"><span class="tok-kw">nakedcc</span></code>
    are obsoleted by <code class="zig"><span class="tok-kw">callconv</span>(.Stdcall)</code> and <code class="zig"><span class="tok-kw">callconv</span>(.Naked)</code>.
    </p>
    <p>
    The enum that <code class="zig"><span class="tok-kw">callconv</span></code> takes as a parameter is defined in
    <code class="zig">std.builtin.CallingConvention</code>:
    </p>
    <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> CallingConvention = <span class="tok-kw">enum</span> {
    Unspecified,
    C,
    Cold,
    Naked,
    Async,
    Interrupt,
    Signal,
    Stdcall,
    Fastcall,
    Vectorcall,
    Thiscall,
    APCS,
    AAPCS,
    AAPCSVFP,
};</code></pre>
    <p>
    This allows the calling convention of a function to depend on
    <code class="zig"><span class="tok-kw">comptime</span></code> logic, which can be useful for dealing with
    code that works differently on different architectures.
    </p>
    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    

    <h2 id="Non-Exhaustive-Enums"><a href="#toc-Non-Exhaustive-Enums">Non-Exhaustive Enums</a> <a class="hdr" href="#Non-Exhaustive-Enums">ยง</a></h2>

      <p>
      A Non-exhaustive enum can be created by adding a trailing '_' field.
      It must specify an integer tag type and may not consume every enumeration value.
      </p>
      <p>
      <a href="https://ziglang.org/documentation/0.6.0/#intToEnum">@intToEnum</a>
      on a non-exhaustive enum never fails.
      </p>
      <p>
      A switch on a non-exhaustive enum can include a '_' prong as an alternative to an
      <code class="zig"><span class="tok-kw">else</span></code> prong
      with the difference being that it makes it a compile error if all the known tag names
      are not handled by the switch.
      </p>
      <p class="file">switch_non_exhaustive_enum.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">const</span> Number = <span class="tok-kw">enum</span>(<span class="tok-type">u8</span>) {
    One,
    Two,
    Three,
    _,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;switch on non-exhaustive enum&quot;</span> {
    <span class="tok-kw">const</span> number = Number.One;
    <span class="tok-kw">const</span> result = <span class="tok-kw">switch</span> (number) {
        .One =&gt; <span class="tok-null">true</span>,
        .Two,
        .Three =&gt; <span class="tok-null">false</span>,
        _ =&gt; <span class="tok-null">false</span>,
    };
    assert(result);
    <span class="tok-kw">const</span> is_one = <span class="tok-kw">switch</span> (number) {
        .One =&gt; <span class="tok-null">true</span>,
        <span class="tok-kw">else</span> =&gt; <span class="tok-null">false</span>,
    };
    assert(is_one);
}</code></pre><pre><code class="shell">$ zig test switch_non_exhaustive_enum.zig
1/1 test &quot;switch on non-exhaustive enum&quot;...OK
All 1 tests passed.
</code></pre>

      <p>
      Non-exhaustive enums are useful for future-proofing code, so that it will
      continue to work correctly even when encountering values that were not
      present at the time the code was written.
      </p>
      <p>
      Various bits in the <a href="#Standard-Library">Standard Library</a> have been updated to use
      non-exhaustive enums rather than numerical constants.
      </p>
    <p>
    Thanks to Vexu, LemonBoy, and daurnimator for contributions related to this feature.
    </p>
    

    <h2 id="Unicode-Character-Literals"><a href="#toc-Unicode-Character-Literals">Unicode Character Literals</a> <a class="hdr" href="#Unicode-Character-Literals">ยง</a></h2>

    <p class="file">unicode_char_lit.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">test</span> <span class="tok-str">&quot;utf8 character literal&quot;</span> {
    <span class="tok-kw">const</span> x = <span class="tok-str">'๐ฉ'</span>;
    std.testing.expect(x == <span class="tok-number">128169</span>);
}</code></pre><pre><code class="shell">$ zig test unicode_char_lit.zig
1/1 test &quot;utf8 character literal&quot;...OK
All 1 tests passed.
</code></pre>

    <p>This makes sense because Zig is defined to have
      <a href="https://ziglang.org/documentation/0.6.0/#Source-Encoding">UTF-8 Source Encoding</a>.
      A unicode character literal is a <code class="zig"><span class="tok-type">comptime_int</span></code> with the value
      equal to the code point.
    </p>
    <p>Thanks to Nick Erdmann for implementing this feature.</p>
    

    <h2 id="Atomics"><a href="#toc-Atomics">Atomics</a> <a class="hdr" href="#Atomics">ยง</a></h2>

    <p>
    Thanks to <a href="#Please-Welcome-Vexu-to-the-Core-Zig-Team">Vexu</a>:
    </p>
    <ul>
      <li>Atomic operations additionally support enums, bools, non-power-of-two integers, and floats.</li>
      <li>There is a new <code class="zig"><span class="tok-builtin">@atomicStore</span></code> builtin.</li>
      <li><code class="zig"><span class="tok-builtin">@cmpxchgWeak</span></code>, <code class="zig"><span class="tok-builtin">@cmpxchgStrong</span></code>, and
        <code class="zig"><span class="tok-builtin">@atomicRmw</span></code> now support being evaluated in
        <code class="zig"><span class="tok-kw">comptime</span></code> code.</li>
    </ul>
    

    <h2 id="Container-Level-Doc-Comments"><a href="#toc-Container-Level-Doc-Comments">Container-Level Doc Comments</a> <a class="hdr" href="#Container-Level-Doc-Comments">ยง</a></h2>

    <pre><code class="zig"><span class="tok-comment">//! This is a container doc comment, which applies to the</span>
<span class="tok-comment">//! entire file rather than the `foo` declaration below.</span>

<span class="tok-comment">/// This is a declaration doc comment, which applies to</span>
<span class="tok-comment">/// the `foo` declaration below.</span>
<span class="tok-kw">const</span> foo = bar;</code></pre>
    <p>Thanks Marc Tiehuis for the proposal (#2288) and
    Vexu for the implementation (#3697).</p>
    

    <h2 id="Comptime-Struct-Fields"><a href="#toc-Comptime-Struct-Fields">Comptime Struct Fields</a> <a class="hdr" href="#Comptime-Struct-Fields">ยง</a></h2>

    <p class="file">comptime_struct_field.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
    a: <span class="tok-type">i32</span>,
    <span class="tok-kw">comptime</span> b: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
};

<span class="tok-kw">test</span> <span class="tok-str">&quot;example&quot;</span> {
    <span class="tok-kw">var</span> foo: Foo = <span class="tok-null">undefined</span>;
    <span class="tok-kw">comptime</span> std.debug.assert(foo.b == <span class="tok-number">1234</span>);
}</code></pre><pre><code class="shell">$ zig test comptime_struct_field.zig
1/1 test &quot;example&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    A comptime struct field requires a default initialization value.
    Loads from a comptime struct field result in a comptime value of the
    default initialization value.
    Stores to a comptime struct field assert that the stored value is the
    default initialization value.
    </p>
    <p>
    Generally, one should use a global const instead of a comptime field.
    The reason for using a comptime field is when you want reflection over
    struct fields to find the data as a field. For example:
    </p>
    <p class="file">csf_example.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">dump</span>(args: <span class="tok-kw">var</span>) <span class="tok-type">void</span> {
    <span class="tok-kw">inline</span> <span class="tok-kw">for</span> (std.meta.fields(<span class="tok-builtin">@TypeOf</span>(args))) |field| {
        std.debug.warn(<span class="tok-str">&quot;{} = {}\n&quot;</span>, .{field.name, <span class="tok-builtin">@field</span>(args, field.name)});
    }
}

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> runtime_float: <span class="tok-type">f32</span> = <span class="tok-number">12.34</span>;
    dump(.{
        .int = <span class="tok-number">1234</span>,
        .float = runtime_float,
        .b = <span class="tok-null">true</span>,
        .s = <span class="tok-str">&quot;hi&quot;</span>,
        .T = [*]<span class="tok-type">f32</span>,
    });
}</code></pre><pre><code class="shell">$ zig build-exe csf_example.zig
$ ./csf_example
int = 1234
float = 1.23400001e+01
b = true
s = hi
T = type
</code></pre>

    <p>
    This will construct an anonymous struct with all comptime fields
    (except <code class="zig">float</code>) and pass it to <code class="zig">dump</code>.
    Each iteration in the for loop will evaluate the <code class="zig"><span class="tok-builtin">@field</span>(...)</code>
    expression and produce a comptime value, except <code class="zig">float</code>, which will
    be a runtime value.
    </p>
    <p>
    This feature makes formatted printing, and <a href="#Tuples-Added-Var-Args-Removed">tuples</a>
    in general, support mixed comptime and runtime values (#3677).
    </p>
    

    <h2 id="Untyped-Struct-Fields"><a href="#toc-Untyped-Struct-Fields">Untyped Struct Fields</a> <a class="hdr" href="#Untyped-Struct-Fields">ยง</a></h2>

    <p>
    It's now possible to omit the type from struct fields. This allows the field
    to have any value of any type. The catch is that it causes the entire struct
    to be required to be <code class="zig"><span class="tok-kw">comptime</span></code>-known.
    </p>
    <p class="file">untyped_struct_fields.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;struct with var field&quot;</span> {
    <span class="tok-kw">const</span> Point = <span class="tok-kw">struct</span> {
        x: <span class="tok-kw">var</span>,
        y: <span class="tok-kw">var</span>,
    };
    <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> pt = Point {
        .x = <span class="tok-number">1</span>,
        .y = <span class="tok-number">2</span>,
    };
    expect(pt.x == <span class="tok-number">1</span>);
    expect(pt.y == <span class="tok-number">2</span>);

    pt.x = <span class="tok-null">true</span>;
    pt.y = <span class="tok-str">&quot;hello&quot;</span>;
    expect(pt.x);
    expect(std.mem.eql(<span class="tok-type">u8</span>, pt.y, <span class="tok-str">&quot;hello&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test untyped_struct_fields.zig
1/1 test &quot;struct with var field&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    The motivation behind this feature is to expose default struct field initialization values
    and sentinel values in <code class="zig"><span class="tok-builtin">@typeInfo</span></code>:
    </p>
    <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> StructField = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    offset: ?<span class="tok-type">comptime_int</span>,
    field_type: <span class="tok-type">type</span>,
    default_value: <span class="tok-kw">var</span>,
};</code></pre>
    <p>
    With Zig 0.6.0, this works now:
    </p>
    <p class="file">type_info_struct.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;access default initialization value&quot;</span> {
    <span class="tok-kw">const</span> Foo = <span class="tok-kw">struct</span> {
        x: <span class="tok-type">i32</span> = <span class="tok-number">1234</span>,
        y: <span class="tok-type">i32</span>,
    };
    <span class="tok-kw">const</span> info = <span class="tok-builtin">@typeInfo</span>(Foo).Struct;
    expect(info.fields[<span class="tok-number">0</span>].default_value.? == <span class="tok-number">1234</span>);
    expect(info.fields[<span class="tok-number">1</span>].default_value == <span class="tok-null">null</span>);
}</code></pre><pre><code class="shell">$ zig test type_info_struct.zig
1/1 test &quot;access default initialization value&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Similarly, the <code class="zig"><span class="tok-builtin">@typeInfo</span></code> for <a href="#Sentinel-Terminated-Pointers">Sentinel-Terminated Pointers</a>
    now exposes the sentinel value.
    </p>
    <p>
    <a href="https://github.com/ziglang/zig/issues/4820">It is planned to rename
    <code class="zig"><span class="tok-kw">var</span></code> to <code class="zig">anytype</code> in this context</a>,
    to disambiguate it from variable declarations.
    </p>
    <p>
    Thanks to LemonBoy for contributions related to this feature.
    </p>
    

    <h2 id="Pointer-Arithmetic-and-Alignment"><a href="#toc-Pointer-Arithmetic-and-Alignment">Pointer Arithmetic and Alignment</a> <a class="hdr" href="#Pointer-Arithmetic-and-Alignment">ยง</a></h2>

    <p>
    Pointer arithmetic now appropriately modifies the alignment of a pointer type:
    </p>
    <p class="file">ptr_arith_align.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;pointer math alignment&quot;</span> {
    <span class="tok-kw">var</span> arr: [<span class="tok-number">10</span>]<span class="tok-type">u8</span> <span class="tok-kw">align</span>(<span class="tok-number">4</span>) = <span class="tok-null">undefined</span>;
    <span class="tok-kw">var</span> runtime_known_2: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;

    <span class="tok-kw">const</span> ptr: [*]<span class="tok-type">u8</span> = &amp;arr;
    <span class="tok-kw">const</span> ptr2 = ptr + <span class="tok-number">1</span>;
    <span class="tok-kw">const</span> ptr3 = ptr + <span class="tok-number">2</span>;
    <span class="tok-kw">const</span> ptr4 = ptr + runtime_known_2;

    <span class="tok-kw">comptime</span> {
        expect(<span class="tok-builtin">@TypeOf</span>(ptr) == [*]<span class="tok-kw">align</span>(<span class="tok-number">4</span>) <span class="tok-type">u8</span>);
        expect(<span class="tok-builtin">@TypeOf</span>(ptr2) == [*]<span class="tok-type">u8</span>);
        expect(<span class="tok-builtin">@TypeOf</span>(ptr3) == [*]<span class="tok-kw">align</span>(<span class="tok-number">2</span>) <span class="tok-type">u8</span>);
        expect(<span class="tok-builtin">@TypeOf</span>(ptr4) == [*]<span class="tok-type">u8</span>);
    }
}</code></pre><pre><code class="shell">$ zig test ptr_arith_align.zig
1/1 test &quot;pointer math alignment&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Thanks to LemonBoy for implementing this (#1528).
    </p>
    

    <h2 id="export"><a href="#toc-export">@export</a> <a class="hdr" href="#export">ยง</a></h2>

    <pre><code class="zig"><span class="tok-builtin">@export</span>(target: <span class="tok-kw">var</span>, <span class="tok-kw">comptime</span> options: std.builtin.ExportOptions) <span class="tok-type">void</span></code></pre>
    <p>
    <code class="zig"><span class="tok-builtin">@export</span></code> now uses <code class="zig">std.builtin.ExportOptions</code>
    to accept its parameters:
    </p>
    <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ExportOptions = <span class="tok-kw">struct</span> {
    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,
    linkage: GlobalLinkage = .Strong,
    section: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,
};</code></pre>
    <p>
    The <code class="zig">section</code> option is new; it is now possible to specify the
    <code class="zig"><span class="tok-kw">linksection</span></code> using <code class="zig"><span class="tok-builtin">@export</span></code>.
    </p>
    <p>
    Thanks LemonBoy for implementing this (#2679).
    </p>
    

    <h2 id="bitSizeOf"><a href="#toc-bitSizeOf">@bitSizeOf</a> <a class="hdr" href="#bitSizeOf">ยง</a></h2>

    <pre><code class="zig"><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>) <span class="tok-type">comptime_int</span></code></pre>
    <p>
    This function returns the number of bits it takes to store <code class="zig">T</code> in memory.
    The result is a target-specific compile time constant.
    </p>
    <p>
    This function measures the size allocated at runtime. For types that are disallowed at runtime,
    such as <code class="zig"><span class="tok-type">comptime_int</span></code> and <code class="zig"><span class="tok-type">type</span></code>, the result is
    <code class="zig"><span class="tok-number">0</span></code>.
    </p>
    <p>
    Note that this value does not necessarily equal <code class="zig"><span class="tok-builtin">@sizeOf</span>(T) * <span class="tok-number">8</span></code>.
    For example, <code class="zig"><span class="tok-builtin">@bitSizeOf</span>(<span class="tok-type">u7</span>)</code> is <code class="zig"><span class="tok-number">7</span></code>, but
    <code class="zig"><span class="tok-builtin">@sizeOf</span>(<span class="tok-type">u7</span>)</code> is <code class="zig"><span class="tok-number">1</span></code>.
    </p>
    <p>
    When the
    <a href="https://github.com/ziglang/zig/issues/3802">accepted proposal for align(0) fields</a>
    is implemented, <code class="zig"><span class="tok-builtin">@bitSizeOf</span></code> measures how many bits a type would take up
    in a struct if all fields were <code class="zig"><span class="tok-kw">align</span>(<span class="tok-number">0</span>)</code>.
    </p>
    <p>
    Thanks to Vexu for the implementation of this.
    </p>
    

    <h2 id="No-More-Capture-Aliasing"><a href="#toc-No-More-Capture-Aliasing">No More Capture Aliasing</a> <a class="hdr" href="#No-More-Capture-Aliasing">ยง</a></h2>

    <p>
    Captured payloads from optionals and tagged-unions are no longer aliases to
    the same memory of the optional or tagged-union. The (unwrapped) payloads are
    copies.
    </p>
    <p class="file">no_capture_aliasing.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;no capture value aliasing&quot;</span> {
    <span class="tok-comment">// In Zig 0.5.0, foo() returns 5678.</span>
    expect(foo() == <span class="tok-number">1234</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> optional_x: ?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

    <span class="tok-kw">if</span> (optional_x) |x| {
        optional_x = <span class="tok-number">5678</span>;
        <span class="tok-kw">return</span> x;
    }

    <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test no_capture_aliasing.zig
1/1 test &quot;no capture value aliasing&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    There are two competing proposals for non-copyable data structures:
    <a href="https://github.com/ziglang/zig/issues/3803">#3803</a>
    <a href="https://github.com/ziglang/zig/issues/3804">#3804</a>
    </p>
    <p>
    When one of these is accepted, it will be a compile error to copy some types.
    to avoid copying, one can denote the capture value to make it a pointer:
    </p>
    <p class="file">capture_aliasing.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;capture value aliasing&quot;</span> {
    expect(foo() == <span class="tok-number">5678</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> optional_x: ?<span class="tok-type">i32</span> = <span class="tok-number">1234</span>;

    <span class="tok-kw">if</span> (optional_x) |*x| {
        optional_x = <span class="tok-number">5678</span>;
        <span class="tok-kw">return</span> x.*;
    }

    <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test capture_aliasing.zig
1/1 test &quot;capture value aliasing&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    

    <h2 id="noasync"><a href="#toc-noasync">noasync</a> <a class="hdr" href="#noasync">ยง</a></h2>

    <p>
    <code class="zig"><span class="tok-kw">noasync</span></code>, similar to <code class="zig"><span class="tok-kw">comptime</span></code>, creates a scope
    in which the programmer asserts there will be no suspension points.
    </p>
    <p>
    Normally, async function calls and awaiting an async function frame introduce a
    <strong>suspension point</strong> at the callsite, causing the containing function
    to have the <code class="zig"><span class="tok-kw">async</span></code> calling convention.
    However, inside a <code class="zig"><span class="tok-kw">noasync</span></code> scope, async function calls and
    awaiting async function frames do not cause a suspension point. Instead, the code
    asserts that the callee never suspends, or in the case of <code class="zig"><span class="tok-kw">await</span></code>,
    that the function frame already has the result completed.
    </p>
    <p>
    This allows a non-async function to call an async function:
    </p>
    <p class="file">noasync.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">test</span> <span class="tok-str">&quot;noasync function call&quot;</span> {
    <span class="tok-kw">const</span> result = <span class="tok-kw">noasync</span> add(<span class="tok-number">50</span>, <span class="tok-number">100</span>);
    expect(result == <span class="tok-number">150</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">add</span>(a: <span class="tok-type">i32</span>, b: <span class="tok-type">i32</span>) <span class="tok-type">i32</span> {
    <span class="tok-kw">if</span> (a &gt; <span class="tok-number">100</span>) {
        <span class="tok-kw">suspend</span>;
    }
    <span class="tok-kw">return</span> a + b;
}</code></pre><pre><code class="shell">$ zig test noasync.zig
1/1 test &quot;noasync function call&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    This is especially useful for <code class="zig">main()</code> to set up
    async functions initially:
    </p>
    <p class="file">async_main.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">var</span> global_frame_1: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> global_frame_2: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> main_frame = <span class="tok-kw">async</span> asyncMain();
    <span class="tok-kw">resume</span> global_frame_1;
    <span class="tok-kw">resume</span> global_frame_2;
    <span class="tok-kw">const</span> result = <span class="tok-kw">noasync</span> <span class="tok-kw">await</span> main_frame;
    std.debug.warn(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{result});
}

<span class="tok-kw">fn</span> <span class="tok-fn">asyncMain</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> a = <span class="tok-kw">async</span> foo();
    <span class="tok-kw">var</span> b = <span class="tok-kw">async</span> bar();
    <span class="tok-kw">return</span> <span class="tok-kw">await</span> a + <span class="tok-kw">await</span> b;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    global_frame_1 = <span class="tok-builtin">@frame</span>();
    <span class="tok-kw">suspend</span>;
    <span class="tok-kw">return</span> <span class="tok-number">1</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">i32</span> {
    global_frame_2 = <span class="tok-builtin">@frame</span>();
    <span class="tok-kw">suspend</span>;
    <span class="tok-kw">return</span> <span class="tok-number">2</span>;
}</code></pre><pre><code class="shell">$ zig build-exe async_main.zig
$ ./async_main
result: 3
</code></pre>

    <p>
    Notice that the function <code class="zig">asyncMain</code> is able to participate in the
    async/await abstraction without having to care about the setup and teardown happening
    in <code class="zig">main</code>.
    </p>
    <p>
    For <a href="#Async-IO">Async I/O</a> in the <a href="#Standard-Library">Standard Library</a>, Zig handles this setup and teardown
    in the <a href="#Start-Code">Start Code</a> that calls <code class="zig">main</code>.
    </p>
    <p>
    Now, watch what happens when we remove <code class="zig"><span class="tok-kw">noasync</span></code> from the above example:
    </p>
    <p class="file">oops_await.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> expect = std.testing.expect;

<span class="tok-kw">var</span> global_frame_1: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;
<span class="tok-kw">var</span> global_frame_2: <span class="tok-kw">anyframe</span> = <span class="tok-null">undefined</span>;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">void</span> {
    <span class="tok-kw">var</span> main_frame = <span class="tok-kw">async</span> asyncMain();
    <span class="tok-kw">resume</span> global_frame_1;
    <span class="tok-kw">resume</span> global_frame_2;
    <span class="tok-kw">const</span> result = <span class="tok-kw">await</span> main_frame;
    std.debug.warn(<span class="tok-str">&quot;result: {}\n&quot;</span>, .{result});
}

<span class="tok-kw">fn</span> <span class="tok-fn">asyncMain</span>() <span class="tok-type">i32</span> {
    <span class="tok-kw">var</span> a = <span class="tok-kw">async</span> foo();
    <span class="tok-kw">var</span> b = <span class="tok-kw">async</span> bar();
    <span class="tok-kw">return</span> <span class="tok-kw">await</span> a + <span class="tok-kw">await</span> b;
}

<span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() <span class="tok-type">i32</span> {
    global_frame_1 = <span class="tok-builtin">@frame</span>();
    <span class="tok-kw">suspend</span>;
    <span class="tok-kw">return</span> <span class="tok-number">1</span>;
}

<span class="tok-kw">fn</span> <span class="tok-fn">bar</span>() <span class="tok-type">i32</span> {
    global_frame_2 = <span class="tok-builtin">@frame</span>();
    <span class="tok-kw">suspend</span>;
    <span class="tok-kw">return</span> <span class="tok-number">2</span>;
}</code></pre><pre><code class="shell">$ zig build-exe oops_await.zig
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:83:1: </span><span class="t31_1">error: </span><span class="t0_1">function with calling convention 'Naked' cannot be async</span>
fn _start() callconv(.Naked) noreturn {
<span class="t32_1">^</span>
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:123:5: </span><span class="t36_1">note: </span><span class="t0_1">async function call here</span>
    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});
    <span class="t32_1">^</span>
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:179:17: </span><span class="t36_1">note: </span><span class="t0_1">async function call here</span>
    std.os.exit(@call(.{ .modifier = .always_inline }, callMainWithArgs, .{ argc, argv, envp }));
                <span class="t32_1">^</span>
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:188:36: </span><span class="t36_1">note: </span><span class="t0_1">async function call here</span>
    return initEventLoopAndCallMain();
                                   <span class="t32_1">^</span>
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:225:12: </span><span class="t36_1">note: </span><span class="t0_1">async function call here</span>
    return @call(.{ .modifier = .always_inline }, callMain, .{});
           <span class="t32_1">^</span>
<span class="t0_1">/home/andy/Downloads/zig/lib/std/start.zig:243:22: </span><span class="t36_1">note: </span><span class="t0_1">async function call here</span>
            root.main();
                     <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/oops_await.zig:11:20: </span><span class="t36_1">note: </span><span class="t0_1">await here is a suspend point</span>
    const result = await main_frame;
                   <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/oops_await.zig:18:12: </span><span class="t36_1">note: </span><span class="t0_1">await here is a suspend point</span>
    return await a + await b;
           <span class="t32_1">^</span>
<span class="t0_1">./docgen_tmp/oops_await.zig:22:22: </span><span class="t36_1">note: </span><span class="t0_1">@frame() causes function to be async</span>
    global_frame_1 = @frame();
                     <span class="t32_1">^</span>
</code></pre>

    <p>
    Here, the <code class="zig"><span class="tok-kw">await</span></code> inside <code class="zig">main</code> is a
    suspension point, which causes <code class="zig">main</code> to have the
    async calling convention, which has a cascading effect, causing <code class="zig">_start</code>
    to have the async calling convention. But <code class="zig">_start</code> already has the
    "naked" calling convention, because it is the entry point from the kernel!
    </p>
    <p>
    We can use <code class="zig"><span class="tok-kw">noasync</span></code> to create a "seam" between async code and blocking
    code, because in this example, we know that <code class="zig">main_frame</code> has already
    completed by the time we call <code class="zig"><span class="tok-kw">await</span></code>.
    </p>
    <p>
    Thanks to Vexu for contributions related to this feature.
    </p>
    

    <h2 id="Deprecated-Builtins-Removed"><a href="#toc-Deprecated-Builtins-Removed">Deprecated Builtins Removed</a> <a class="hdr" href="#Deprecated-Builtins-Removed">ยง</a></h2>

    <p>
    Many deprecated builtins have been removed.
    </p>
    <p>
    Thanks to Maciej Walczak for removing these and implementing the corresponding std lib functions:
    </p>
    <ul>
      <li><code class="zig"><span class="tok-builtin">@bytesToSlice</span></code> becomes <code class="zig">mem.bytesAsSlice</code></li>
      <li><code class="zig"><span class="tok-builtin">@sliceToBytes</span></code> becomes <code class="zig">mem.sliceAsBytes</code></li>
    </ul>
    <p>
    Thanks to Vexu for removing these:
    </p>
    <ul>
      <li><code class="zig"><span class="tok-builtin">@typeId</span></code> becomes <code class="zig"><span class="tok-builtin">@typeInfo</span></code> tag-type</li>
      <li><code class="zig"><span class="tok-builtin">@memberCount</span></code> becomes <code class="zig">std.meta.fields(T).len</code></li>
      <li><code class="zig"><span class="tok-builtin">@memberName</span></code> becomes <code class="zig">std.meta.fields(T)[i].name</code></li>
      <li><code class="zig"><span class="tok-builtin">@memberType</span></code> becomes <code class="zig">std.meta.fields(T)[i].field_type</code></li>
      <li><code class="zig"><span class="tok-builtin">@ArgType</span></code> becomes <code class="zig"><span class="tok-builtin">@typeInfo</span>(T).Fn.args[i].arg_type.?</code></li>
      <li><code class="zig"><span class="tok-builtin">@IntType</span></code> becomes <code class="zig">std.meta.IntType</code></li>
    </ul>
    

    <h2 id="Allow-Empty-Inferred-Error-Sets"><a href="#toc-Allow-Empty-Inferred-Error-Sets">Allow Empty Inferred Error Sets</a> <a class="hdr" href="#Allow-Empty-Inferred-Error-Sets">ยง</a></h2>

    <p>
    The body of functions returning inferred error sets are no longer required
    to return any possible errors.
    </p>
    <p class="file">empty_inferred_error_set.zig</p><pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">foo</span>() !<span class="tok-type">void</span> {}

<span class="tok-kw">test</span> <span class="tok-str">&quot;&quot;</span> {
    foo() <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {};
}</code></pre><pre><code class="shell">$ zig test empty_inferred_error_set.zig
1/1 test &quot;&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Thanks to LemonBoy for implementing this.
    </p>
    

    <h2 id="TypeOf-Supports-Multiple-Parameters"><a href="#toc-TypeOf-Supports-Multiple-Parameters">@TypeOf Supports Multiple Parameters</a> <a class="hdr" href="#TypeOf-Supports-Multiple-Parameters">ยง</a></h2>

    <p>
    Multiple parameters can now be specified with <code class="zig"><span class="tok-builtin">@TypeOf</span></code> in cases where
    <a href="https://ziglang.org/documentation/0.6.0/#Peer-Type-Resolution">Peer Type Resolution</a>
    is needed.
    </p>
    <pre><code class="zig"><span class="tok-comment">// std.math.max</span>
<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">max</span>(x: <span class="tok-kw">var</span>, y: <span class="tok-kw">var</span>) <span class="tok-builtin">@TypeOf</span>(x, y) {
    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (x &gt; y) x <span class="tok-kw">else</span> y;
}</code></pre>
    <p>
    Thanks to Josh Wolfe for proposal and LemonBoy for implementing this.
    </p>
    

    <h2 id="Underscore-Separators-in-Number-Literals"><a href="#toc-Underscore-Separators-in-Number-Literals">Underscore Separators in Number Literals</a> <a class="hdr" href="#Underscore-Separators-in-Number-Literals">ยง</a></h2>

    <p>
    Underscores may be placed between two digits as a visual separator.
    Consecutive underscores are not allowed.
    </p>
    <pre><code class="zig"><span class="tok-kw">fn</span> <span class="tok-fn">digits</span>() <span class="tok-type">void</span> {
    _ = <span class="tok-number">1_234_567</span>;
    _ = <span class="tok-number">0xff00_00ff</span>;
    _ = <span class="tok-number">0b10000000_10101010</span>;
    _ = <span class="tok-number">0b1000_0000_1010_1010</span>;
    _ = <span class="tok-number">0x123_190.109_038_018p102</span>;
    _ = <span class="tok-number">3.14159_26535_89793</span>;
}</code></pre>
    <p>
    Thanks to Marc Tiehuis for original proposal and momumi for making a strong case
    to re-open the proposal, and for implementing it.
    </p>
    

    <h2 id="Slicing-with-Comptime-Indexes"><a href="#toc-Slicing-with-Comptime-Indexes">Slicing with Comptime Indexes</a> <a class="hdr" href="#Slicing-with-Comptime-Indexes">ยง</a></h2>

    <p>
    When slicing and the length is comptime-known, the expression type is now
    a single-item pointer to array <code class="zig">*[N]T</code> .
    Prior to this change an error-prone <code class="zig"><span class="tok-builtin">@ptrCast</span></code> was required.
    </p>
    <p class="file">slice_comptime_indexes.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);
<span class="tok-kw">const</span> assert = std.debug.assert;

<span class="tok-kw">test</span> <span class="tok-str">&quot;slicing with comptime indexes&quot;</span> {
    <span class="tok-kw">var</span> a = <span class="tok-str">&quot;abcdefgh&quot;</span>.*;
    assert(<span class="tok-builtin">@TypeOf</span>(a) == [<span class="tok-number">8</span>:<span class="tok-number">0</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// both indices are comptime, thus length is comptime</span>
    <span class="tok-kw">var</span> b = a[<span class="tok-number">3</span>..<span class="tok-number">6</span>];
    assert(<span class="tok-builtin">@TypeOf</span>(b) == *[<span class="tok-number">3</span>]<span class="tok-type">u8</span>);

    <span class="tok-comment">// length is runtime</span>
    <span class="tok-kw">var</span> runtime_i: <span class="tok-type">usize</span> = <span class="tok-number">3</span>;
    <span class="tok-kw">var</span> c = a[runtime_i..<span class="tok-number">6</span>];
    assert(<span class="tok-builtin">@TypeOf</span>(c) == []<span class="tok-type">u8</span>);

    <span class="tok-comment">// copy array</span>
    a[<span class="tok-number">0</span>..<span class="tok-number">3</span>].* = a[<span class="tok-number">5</span>..<span class="tok-number">8</span>].*;
    assert(std.mem.eql(<span class="tok-type">u8</span>, &amp;a, <span class="tok-str">&quot;fghdefgh&quot;</span>));
}</code></pre><pre><code class="shell">$ zig test slice_comptime_indexes.zig
1/1 test &quot;slicing with comptime indexes&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Thanks to Jimmi Holst Christensen for proposing this.
    </p>
    

    <h2 id="errdefer-Payload"><a href="#toc-errdefer-Payload">errdefer Payload</a> <a class="hdr" href="#errdefer-Payload">ยง</a></h2>

    <p>
    <code class="zig"><span class="tok-kw">errdefer</span></code> now provides syntax to access the in-flight error.
    </p>
    <p class="file">errdefer_payload.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">fn</span> <span class="tok-fn">perform</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">errdefer</span> |err| std.debug.assert(err == <span class="tok-kw">error</span>.Overflow);
    _ = <span class="tok-kw">try</span> std.math.add(<span class="tok-type">u8</span>, <span class="tok-number">255</span>, <span class="tok-number">1</span>);
}

<span class="tok-kw">test</span> <span class="tok-str">&quot;errdefer with payload&quot;</span> {
    perform() <span class="tok-kw">catch</span> <span class="tok-kw">return</span>;
    <span class="tok-kw">unreachable</span>;
}</code></pre><pre><code class="shell">$ zig test errdefer_payload.zig
1/1 test &quot;errdefer with payload&quot;...OK
All 1 tests passed.
</code></pre>

    <p>
    Thanks to Byron Heads for the proposal and LemonBoy for implementing this.
    </p>
    <p>Follow-up proposal: <a href="https://github.com/ziglang/zig/issues/5018">errdefer with unreachable should allow function type to not have an error union</a></p>
    

    

    <h1 id="Standard-Library"><a href="#toc-Standard-Library">Standard Library</a> <a class="hdr" href="#Standard-Library">ยง</a></h1>

    <p>
    There are so many breaking changes that it is not feasible to list them all here. Instead,
    the release notes will cover contributions and high-level topics. In the future, it should
    be possible to use the same backend of <a href="#Documentation-Generation">Documentation Generation</a> to make a tool
    that detects all API changes - additions, removals, and modifications.
    </p>
    <ul>
      <li>Various contributors updated the standard library to use newer Zig syntax, such as
      anonymous enum literals, and to fix regressions from breaking language changes.</li>
      <li>LemonBoy added support for the statx syscall.</li>
      <li>Jonathan Marler fixed accept function API.</li>
      <li>std.os.accept4: improve docs and integrate with evented I/O</li>
      <li>Jonathan Marler improved TTY detection to take into account TERM=dumb.</li>
      <li><code class="zig">std.os.dup2</code> makes EBADF more obvious in stack traces.</li>
      <li>lukechampine added an AES implementation to <code class="zig">std.crypto</code>.
      data-man improved the code, replacing variables with constants. lukechampine
      additionally added support for AES-CTR.</li>
      <li>daurnimator updated the standard library OS bits to Linux 5.6, added missing OS bits,
        organized declarations, and swapped constants for <a href="#Non-Exhaustive-Enums">Non-Exhaustive Enums</a>.</li>
      <li>Brendan Hansknecht improved big ints to use the more efficient karatsuba algorithm
        for multiplication.</li>
      <li>daurnimator contributed LinearFifo which is useful for buffers. schroffl and Tetralux
        contributed improvements.</li>
      <li><code class="zig">std.ChildProcess.spawn</code> now has a consistent error set across targets.</li>
      <li><code class="zig">std.io.getStdOut</code> and related functions no longer can error.
        Thanks to the
        <a href="https://en.wikipedia.org/wiki/Process_Environment_Block">Windows Process Environment Block</a>,
        it is possible to obtain handles
      to the standard input, output, and error streams without the possibility of failure.</li>
      <li>dbandstra added <code class="zig">std.math.tau</code> constant (equivalent to <code class="zig"><span class="tok-number">2</span> * pi</code>).</li>
      <li>Johan Bolmsjรถ improved <code class="zig">std.testing.expectEqual</code> to show differing pointer values, avoiding confusion when the values pointed to are the same.</li>
      <li><code class="zig">std.heap.direct_allocator</code> is renamed to <code class="zig">std.heap.page_allocator</code>, to make it more clear that this is not an appropriate general-purpose allocator.</li>
      <li>Benjamin Feng size-optimized the std.sort internal binary search algorithm.</li>
      <li>LemonBoy added <code class="zig">std.sort.binarySearch</code>. (#4337)</li>
      <li><code class="zig">std.elf</code> API updated to remove redundant namespacing, and
        integrate with <code class="zig">std.Target.Arch</code>.</li>
      <li>Felix Queiรner implemented <code class="zig">std.testing.expectEqual</code> for tagged unions. (#3773)
      </li>
      <li><code class="zig">std.math</code>: remove constants that should be expressions. There were
        four cases where the value can be represented in fewer characters with
        expressions, which will be guaranteed to happen at compile-time, and
        have the same or better precision.
      </li>
      <li>Robin Voetter made improvements to <code class="zig">std.sort</code>:<ul>
          <li>Added <code class="zig">isSorted</code>.</li>
          <li>Updated <code class="zig">max</code> to accept const slices, and added tests.</li>
          <li>Updated <code class="zig">min</code> and <code class="zig">max</code> to return <code class="zig">?T</code>.</li>
          <li>Added <code class="zig">argMax</code> and <code class="zig">argMin</code> which return indexes rather than values.</li>
        </ul>
      </li>
      <li><code class="zig">std.fmt.ParseUnsignedError</code> is now public.</li>
      <li>frmdstryr put in a hot path for <code class="zig">std.io.BufferedInStream.readByte</code>,
      speeding it up by ~75% (#3858).</li>
      <li>Dynamic library loading API functions are improved to follow the standard conventions
          with regards to filename parameters.</li>
      <li>LemonBoy improved <code class="zig">std.ChildProcess</code> to use eventfds on Linux
        rather than pipe for communicating an error from child to parent process. (#819)</li>
      <li>Dmitry Atamanov and daurnimator improved
        <code class="zig">std.unicode.utf8ToUtf16Le</code> to support surrogate pairs. (#3923)</li>
      <li>daurnimator improved the performance of unicode functions. (#3987)</li>
      <li>daurnimator updated <code class="zig">std.meta.TagPayloadType</code> to take the tag type of the union.</li>
      <li>lukechampine implemented ChaCha20-Poly1305 AEAD. (#4011)</li>
      <li>Luna added <code class="zig">std.os.memfd_create</code>. (#3687)</li>
      <li>data-man added <code class="zig">std.os.getrusage</code>. (#3854)</li>
      <li>Nathan Michaels added removeIndex function to PriorityQueue. (#4070)</li>
      <li>Jonathan Marler added <code class="zig">std.os.windows.WaitForSingleObject</code>.</li>
      <li>Hersh Krishna added <code class="zig">std.math.clamp</code>.</li>
      <li>Shawn Landden made breaking changes to <code class="zig">std.rb</code> to make it thread-safe.</li>
      <li>daurnimator updated <code class="zig">std.mem.Allocator</code> interface to set
        memory to undefined when freed (#4087). However note that it is
        <a href="https://github.com/ziglang/zig/issues/4298">planned to revert this and implement this as part of allocator implementations rather than the interface</a>.
      </li>
      <li>LemonBoy made <code class="zig">writeByteNTimes</code> faster and leaner.</li>
      <li>nofmal added a basic Linux termios implementation.</li>
      <li>daurnimator added a Gimli based PRNG to <code class="zig">std.rand</code>, added
        gimli to the crypto hash benchmark, and added AEAD modes for Gimli. (#4369)</li>
      <li>Felix (xq) Queiรner made <code class="zig">std.heap.ArenaAllocator.deinit</code> not require a mutable reference.</li>
      <li>Implement <code class="zig">std.os.faccessat</code> for Windows.</li>
      <li>Support the concept of a target not having a dynamic linker.</li>
      <li>Improved handling of environment variables on Windows.<ul>
          <li>
            std.os.getenv and std.os.getenvZ have nice compile errors when not linking
            libc and using Windows.
          </li>
          <li>
            std.os.getenvW is provided as a Windows-only API that does not require
            an allocator. It uses the Process Environment Block.
            std.process.getEnvVarOwned is improved to be a simple wrapper on top of
            std.os.getenvW.
          </li>
          <li>
            std.process.getEnvMap is improved to use the Process Environment Block
            rather than calling GetEnvironmentVariableW.
          </li>
          <li>
            std.zig.system.NativePaths uses process.getEnvVarOwned instead of
            std.os.getenvZ, which works on Windows as well as POSIX.
          </li>
        </ul>
      </li>
      <li>Heide Onas Auri improved <code class="zig">std.time.Timer.lap</code> to only
      read system time once. (#4533)</li>
      <li><code class="zig">std.Thread.cpuCount</code> on Windows uses the PEB,
        rather than calling GetSystemInfo from kernel32.dll. Also remove OutOfMemory
        from the error set.</li>
      <li>Jared Miller implemented <code class="zig">std.unicode.utf8ToUtf16LeStringLiteral</code>
        which can be used to provide convenient "wide string literals": <code class="zig">w(<span class="tok-str">&quot;foo&quot;</span>)</code>
      </li>
      <li>LemonBoy added <code class="zig">std.os.fnctl</code></li>
      <li>Joachim Schmidt improved bigint comparison code to use <code class="zig">math.Order</code> rather than <code class="zig"><span class="tok-type">i8</span></code> (#4791)</li>
      <li>Ilmari Autio improved <code class="zig">std.os.getenv</code> and related functions to be
        ascii-case-insensitive on Windows. (#4608)</li>
      <li>joachimschmidt557 moved <code class="zig">std.big.rational.gcd</code> to <code class="zig">std.big.int.gcd</code></li>
      <li>Phil Schumann improved <code class="zig">std.zig.parseStringLiteral</code> to support
        hex and unicode escapes. (#4678)</li>
      <li>
        <code class="zig">std.io.readLine</code> is removed.
    <br><br>
    This was deceptive. It was always meant to be sort of a "GNU readline"
    sort of thing where it provides a Command Line Interface to input text.
    However that functionality did not exist and it was basically a red
    herring for people trying to read line-delimited input from a stream.
    (See <a href="#IO-Streams">I/O Streams</a> for that.)
    <br><br>
    In this commit the API is deleted, so that people can find the proper
    API more easily.
    <br><br>
    A CLI text input abstraction would be useful but may not even need to be
    in the standard library. The guess_number CLI game example gets by just
    fine by using <code class="zig">std.fs.File.read</code>.
      </li>
      <li>
        std.os.execvpe related functions support optionally expanding argv[0] into the absolute
        path based on the PATH environment variable. This can be useful to work around a third
        party program which improperly using argv[0] to find the path to its own executable.
      </li>
      <li>
        <code class="zig">std.os.execve</code> had the wrong name; it should have been
        <code class="zig">std.os.execvpe</code>. This is now corrected. It is also
        improved to handle <code class="zig">ENOTDIR</code> (#3415).
      </li>
      <li>
        Introduce <code class="zig">std.os.execveZ</code> which does not look at PATH, and uses
        null terminated parameters, matching POSIX ABIs. It does not require an allocator.
      </li>
      <li>
        Introduce <code class="zig">std.os.execvpeZ</code>, which is like <code class="zig">execvpe</code>
        except it uses null terminated parameters, matching POSIX ABIs, and thus
        does not require an allocator.
      </li>
      <li>
        Sebsatian Keller added std.math constants such as log2e and sqrt2.
        Note that with #425 solved these would not be needed, and would be removed.
      </li>
    </ul>

    <h2 id="Async-IO"><a href="#toc-Async-IO">Async I/O</a> <a class="hdr" href="#Async-IO">ยง</a></h2>

    <p>
    Async I/O in 0.6.0 is still experimental, but rapidly approaching usable. 
    </p>
    <p>
    kprotty contributed significant improvements to synchronization primitives. kprotty writes:
    </p>
    <p><code class="zig">std.Mutex</code> uses a simple locking scheme for Linux,
    relies on CriticalSection for Windows and falls back to spinlocking on other platforms.
    There are two parts towards improving it:</p>
    <p><strong>1) Adaptive Locking</strong></p>
    <p>
    For high contention cases, eager blocking mutexes incur a penalty of a syscall when they
    may not need to. In order to address this, the mutex can spin for a little bit trying to
    acquire the lock similar to a spinlock before deciding to block. This improves performance
    when the time spent in the critical section is minimal and acquiring/releasing is done
    frequently. The implementation chosen for this was that of lock_futex.go from Golang 1.13
    as it provides a nice balance between spinning and deciding to block (another possibility
    could be rust/webkit `parking_lot`). Because this implementation only needs a futex interface,
    it can be reused:
    </p>
    <p><strong>2) Parker API</strong></p>
    <p>
    Most synchronization primitives such as Mutexes, RwLocks, Condvars, Events and Semaphores
    can be built upon atomic instructions and futexes for handling blocking. Another point of
    this change was to setup a cross-platform futex (Parker) interface in which other primitives
    as listed above could be built off of. The default one provided is
    <code class="zig">ThreadParker</code> which differs from the current blocking implementation scheme:
    </p>
    <ul>
      <li>On Windows, it detects at runtime whether to use WaitOnAddress
        (supported since Win8+ and most similar to linux futex) or NT Keyed Events
        (supported since WinXP+ and is the inner backing of CriticalSection).
        This allows the distinction between std.Mutex and std.StaticallyInitializedMutex to
        dissapear as it can now be initialized statically
      </li>
      <li>On POSIX platforms, it uses <code class="zig">pthread_cond_t</code> for synchronization
        which also supports static initialization. This fares better for longer blocking
        critical sections compared to the spinlock default of the current std.Mutex implementation.
      </li>
      <li>On Linux, it still uses <code class="zig">linux_futex</code> so not many improvements
        besides adaptive spinning there
      </li>
    </ul>
    <p><strong>Results &amp; Future Implications</strong></p>
    <p>
    Because the Parker now has a standardized interface, one could replace
    <code class="zig">ThreadParker</code> with something like <code class="zig">AsyncParker</code>
    and reuse the synchronization primitive code for <code class="zig">std.event</code>
    synchronization objects. In order to demonstrate this, I've provided some example
    code for <code class="zig">AsyncParker</code> as well as a naive benchmark to test
    the performance of <code class="zig">std.Mutex</code> in comparison to this new adaptive
    mutex: <a href="https://github.com/kprotty/zig-adaptive-lock/">zig-adaptive-lock</a>
    </p>
    <p>
    The results for high contended, small critical section cases are promising:
    </p>
    <ul>
      <li>Windows 10: 7-8x speedup</li>
      <li>MacOSX: 19-22x speedup</li>
      <li>Linux (Pthread): 2x speedup</li>
      <li>Linux (Futex): 2x speedup</li>
    </ul>
    <p>
    These synchronization primitives are building blocks for an <strong>event loop</strong>,
    which is what drives async I/O.
    </p>
    <p>
    In 0.6.0, you can start to see the ideas behind the standard library's event loop
    coming together. Notably, <a href="#Start-Code">Start Code</a> will set up an event loop before
    calling main(), when the root source file defines:
    <pre><code class="zig"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> io_mode = .evented;</code></pre>
    This means that
    <em>main() is now allowed to use <code class="zig"><span class="tok-kw">await</span></code></em>.
    Same with tests, and <code>zig test</code> supports
    <code>--test-evented-io</code> which affects whether the test runner sets
    <code class="zig">io_mode</code> to evented or blocking.
    </p>
    <p>
    The standard library's async I/O integration, together with <a href="#IO-Streams">I/O Streams</a> improvements, are
    now capable of passing behavior tests with <code>--test-evented-io</code> enabled.
    Standard library tests are now compiling successfully with evented I/O mode, but the
    event loop implementation needs to be improved in order for tests to pass. Additionally,
    "glue" code is needed to be added to the event loop implementation to support more
    operating systems. It's not quite stable enough to be added to CI <a href="#Test-Coverage">Test Coverage</a>.
    </p>
    <p>
    In previous versions of Zig, there was a <code class="zig">std.event</code> namespace for APIs
    that only applied to evented I/O, but in this release, many of these APIs have been removed,
    superceded by normal APIs integrating properly into async I/O. For example,
    <code class="zig">std.event.fs</code> is removed and all the normal <code class="zig">std.fs</code>
    (<a href="#Filesystem">Filesystem</a>) APIs work correctly for both blocking and evented I/O modes.
    </p>
    <p>
    Here is an example of a simple program that writes to a file:
    </p>
    <p class="file">write_file_blocking.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;hello.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;hello\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe write_file_blocking.zig
$ ./write_file_blocking
</code></pre>

    <p>
    Looking at the strace, we can see it is quite simple:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x233190)       = 0
rt_sigaction(SIGSEGV, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGILL, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
rt_sigaction(SIGBUS, {sa_handler=0x22a8d0, sa_mask=[], sa_flags=SA_RESTORER|SA_RESTART|SA_RESETHAND|SA_SIGINFO, sa_restorer=0x204310}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "hello\n", 6)                  = 6
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    Set up thread-local storage, attach some signal handlers for
    <a href="#Debug-Info-and-Stack-Traces">debugging</a>, openat, write, close, done.
    Now we enable evented I/O:
    </p>
    <p class="file">write_file_evented.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> io_mode = .evented;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;hello.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;hello\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe write_file_evented.zig
$ ./write_file_evented
</code></pre>

    <p>
    I can't paste the full strace output here, because it is too long, but I'll highlight some
    of the interesting parts:
    </p>
    <pre><code>clone(child_stack=0x7fe36dbdeff8, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID|0x400000strace: Process 8891 attached
, parent_tid=[8891], tls=0x7fe36dbdf028, child_tidptr=0x7fe36dbdf000) = 8891
futex(0x7fe36dbdf000, FUTEX_WAIT, 8891, NULL <unfinished ...>
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = 0
[pid  8891] openat(AT_FDCWD, "hello.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 20
[pid  8891] epoll_ctl(18, EPOLL_CTL_ADD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = 0
[pid  8891] write(20, "hello\n", 6)     = 6
[pid  8891] epoll_ctl(18, EPOLL_CTL_MOD, 17, {EPOLLIN|EPOLLOUT|EPOLLONESHOT|EPOLLET, {u32=1841168864, u64=140614775472608}}) = 0
[pid  8891] futex(0x260b50, FUTEX_WAIT, 0, NULL <unfinished ...>
[pid  8891] <... futex resumed>)        = -1 EAGAIN (Resource temporarily unavailable)
[pid  8891] close(20 <unfinished ...>
[pid  8891] <... close resumed>)        = 0
[pid  8891] exit(0 <unfinished ...>
[pid  8891] <... exit resumed>)         = ?
<... futex resumed>)                    = -1 EAGAIN (Resource temporarily unavailable)
exit_group(0)                           = ?</code></pre>
    <p>
    Here we can see that a separate thread is created, which ends up doing the file system I/O.
    Some operating systems such as Linux do not have async file system support, and so the technique
    used by evented I/O libraries is to have a thread pool for doing blocking operations. In this way,
    you can make anything async by giving the task to another thread.
    </p>
    <p>
    Now that Linux has <code>io_uring</code>, this could be improved. With Zig's
    <a href="#OS-Version-Ranges">OS Version Ranges</a>, the event loop code could be improved to detect if io_uring is
    within the target OS version range, and take advantage of it if so. If the minimum OS version
    is high enough, the non-io_uring code could be omitted, and if the maximum OS version is low
    enough, the io_uring code could be omitted. If the OS version range includes both, then the
    code should try io_uring, and fall back at runtime to a non-io_uring strategy.
    </p>
    <p>
    Anyway, the point here is that because evented I/O is enabled, it now becomes meaningful
    to express concurrency:
    </p>
    <p class="file">concurrent.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">const</span> io_mode = .evented;

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a_frame = <span class="tok-kw">async</span> doA();
    <span class="tok-kw">var</span> b_frame = <span class="tok-kw">async</span> doB();

    <span class="tok-kw">try</span> <span class="tok-kw">await</span> a_frame;
    <span class="tok-kw">try</span> <span class="tok-kw">await</span> b_frame;
}

<span class="tok-kw">fn</span> <span class="tok-fn">doA</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;a.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;A\n&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">doB</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;b.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;B\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe concurrent.zig
$ ./concurrent
</code></pre>

    <p>
    I'll refrain from pasting more strace output here, but now we can start to see
    things happening in parallel (depending on the OS support for async file system I/O, or
    the file system thread pool size).
    </p>
    <p>
    Finally, I want to point out one crucial point about Zig's async I/O.
    <strong>It still works if you switch back to blocking I/O</strong>:
    </p>
    <p class="file">async_blocking.zig</p><pre><code class="zig"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);

<span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {
    <span class="tok-kw">var</span> a_frame = <span class="tok-kw">async</span> doA();
    <span class="tok-kw">var</span> b_frame = <span class="tok-kw">async</span> doB();

    <span class="tok-kw">try</span> <span class="tok-kw">await</span> a_frame;
    <span class="tok-kw">try</span> <span class="tok-kw">await</span> b_frame;
}

<span class="tok-kw">fn</span> <span class="tok-fn">doA</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;a.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;A\n&quot;</span>);
}

<span class="tok-kw">fn</span> <span class="tok-fn">doB</span>() !<span class="tok-type">void</span> {
    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(<span class="tok-str">&quot;b.txt&quot;</span>, .{});
    <span class="tok-kw">defer</span> file.close();

    <span class="tok-kw">try</span> file.writeAll(<span class="tok-str">&quot;B\n&quot;</span>);
}</code></pre><pre><code class="shell">$ zig build-exe async_blocking.zig --release-fast
$ ./async_blocking
</code></pre>

    <p>
    This time I will show the strace since it's very short:
    </p>
    <pre><code>arch_prctl(ARCH_SET_FS, 0x203cf0)       = 0
openat(AT_FDCWD, "a.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "A\n", 2)                      = 2
close(3)                                = 0
openat(AT_FDCWD, "b.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, "B\n", 2)                      = 2
close(3)                                = 0
exit_group(0)                           = ?</code></pre>
    <p>
    You can see that the async stuff folded into simple, linear, blocking code.
    </p>
    <p>
    This is a big deal. It means that Zig code can express concurrency, yet
    be reusable in both a blocking I/O and an evented I/O environment. There is no
    "async-std".
    <em>The Zig Standard Library supports both async and blocking I/O with the same codebase</em>.
    </p>
    <p>
    Thanks to Benjamin Feng, Vexu, and Timon Kruiper for contributions related to this feature.
    </p>

    

    <h2 id="Debug-Info-and-Stack-Traces"><a href="#toc-Debug-Info-and-Stack-Traces">Debug Info and Stack Traces</a> <a class="hdr" href="#Debug-Info-and-Stack-Traces">ยง</a></h2>

    <p>TODO</p>
    TODO mention LemonBoy's improvements which got stack traces working in release builds
commit b164e0ae5599610e39804845331caab612010c13
Author: LemonBoy <thatlemon@gmail.com>
Date:   Sun Oct 13 17:37:04 2019 +0200

    Fix stack iteration stop condition

commit c8b6e552991136e3a45095007ae4c3594be02ef9
Author: LemonBoy <thatlemon@gmail.com>
Date:   Mon Nov 4 09:58:02 2019 +0100

    Make the `leb` module available to non-std code


commit 3500b41bfed159b54b951b7cee5ff404ae5fbbda
Author: Rocknest <35231115+Rocknest@users.noreply.github.com>
Date:   Wed Jan 29 16:57:43 2020 +0200

    Bring windows segfault handler on par with (#4319)

commit 958f00f1c71f205ce738433d00e9da7dde060f14
Author: LemonBoy <thatlemon@gmail.com>
Date:   Sat Feb 1 23:58:02 2020 +0100

    Don't generate any type info for void return types
    
    Closely matches what the LLVM debug emitter expects, the generated DWARF
    infos are now standard-compliant.

commit cfcaf09cce38821f8b82b840db537d7082a7a8dc
Author: LemonBoy <thatlemon@gmail.com>
Date:   Wed Feb 5 23:40:36 2020 +0100

    debug: Improve the frame-walking strategy
    
    Clean up the code a bit and introduce a few checks meant to avoid
    overshooting the end of the frame chain.
    The code is now stable enough not to cause panics during the call frame
    walking.

commit be02616c869c5fe089bc9a80ea44817df2f5c2ba
Author: LemonBoy <thatlemon@gmail.com>
Date:   Fri Feb 7 16:06:33 2020 +0100

    debug: Show a nice error message on SIGBUS

    TODO mention LemonBoy's work on multiple threads panicking (#4497)

commit c8669a4cf834a6d1dadd9260e94f1781ceed0ec3
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Feb 26 14:33:10 2020 -0500

    improve debug info for optionals

commit 9d19d9008eb70d069b799dd65a68bb410a5dff8e
Author: LemonBoy <thatlemon@gmail.com>
Date:   Sun Mar 22 22:47:28 2020 +0100

    debug: Correct version check in debug_line parser
    
    Version 3 is similar to version 2 plus more opcodes.

    

    <h2 id="Formatted-Printing"><a href="#toc-Formatted-Printing">Formatted Printing</a> <a class="hdr" href="#Formatted-Printing">ยง</a></h2>

    <p>TODO look at git shortlog</p>

    <p>
    Thanks to daurnimator, LemonBoy, Benjamin Feng, Felix Queiรner, Michael Dusan,
    Nathan Michaels, data-man, frmdstryr, markfirmware, shiimizu, and vegecode for
    contributions related to this feature.
    </p>
    

    <h2 id="IO-Streams"><a href="#toc-IO-Streams">I/O Streams</a> <a class="hdr" href="#IO-Streams">ยง</a></h2>

    TODO
commit ba0e3be5cfa2f60f2f9d2a4eb319408f972796c2
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Mar 10 15:27:45 2020 -0400

    (breaking) rework stream abstractions #4710
    
    The main goal here is to make the function pointers comptime, so that we
    don't have to do the crazy stuff with async function frames.
    
    Since InStream, OutStream, and SeekableStream are already generic
    across error sets, it's not really worse to make them generic across the
    vtable as well.
    
    See #764 for the open issue acknowledging that using generics for these
    abstractions is a design flaw.
    
    See #130 for the efforts to make these abstractions non-generic.
    
    This commit also changes the OutStream API so that `write` returns
    number of bytes written, and `writeAll` is the one that loops until the
    whole buffer is written.
    

    <h2 id="Filesystem"><a href="#toc-Filesystem">Filesystem</a> <a class="hdr" href="#Filesystem">ยง</a></h2>

    <p>TODO talk about all the file system API changes</p>
    TODO Mention stratact's improvements to make directory iteration not require heap allocation.
    TODO mention sendfile support (Thanks Terin Stock for contributing initial os.zig implementation)

commit 5b1a492012241276a4b7539ca6664234f0629c79
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Oct 20 21:48:23 2019 -0400

    breaking: improve std.fs directory handling API
    
     * Added `std.c.unlinkat` and `std.os.unlinkat`.
     * Removed `std.fs.MAX_BUF_BYTES` (this declaration never made it to
       master branch)
     * Added `std.fs.Dir.deleteTree` to be used on an open directory handle.
     * `std.fs.deleteTree` has better behavior for both relative and
       absolute paths. For absolute paths, it opens the base directory
       and uses that handle for subsequent operations. For relative paths,
       it does a similar strategy, using the cwd handle.
     * The error set of `std.fs.deleteTree` is improved to no longer have
       these possible errors:
       - OutOfMemory
       - FileTooBig
       - IsDir
       - DirNotEmpty
       - PathAlreadyExists
       - NoSpaceLeft
     * Added `std.fs.Dir.posix_cwd` which is a statically initialized
       directory representing the current working directory.
     * The error set of `std.Dir.open` is improved to no longer have these
       possible errors:
       - FileTooBig
       - IsDir
       - NoSpaceLeft
       - PathAlreadyExists
       - OutOfMemory
     * Added more alternative functions to `std.fs` for when the path
       parameter is a null terminated string. This can sometimes be more
       effecient on systems which have an ABI based on  null terminated
       strings.
     * Added `std.fs.Dir.openDir`, `std.fs.Dir.deleteFile`, and
       `std.fs.Dir.deleteDir` which all operate on an open directory handle.
     * `std.fs.Walker.Entry` now has a `dir` field, which can be used to do
       operations directly on `std.fs.Walker.Entry.basename`, avoiding
       `error.NameTooLong` for deeply nested paths.
     * Added more docs to `std.os.OpenError`
    
    This commit does the POSIX components for these changes. I plan to
    follow up shortly with a commit for Windows.

commit 555a2c03286507ffe4bd3bea2154dbfb719ebef1
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Thu Mar 19 14:38:21 2020 -0400

    (breaking) std.fs.copyFile now integrates with Dir
    
    Removed:
     * `std.fs.updateFile`
     * `std.fs.updateFileMode`
     * `std.fs.copyFile`
     * `std.fs.copyFileMode`
    
    Added:
     * `std.fs.Dir.copyFile`
     * `std.fs.copyFileAbsolute`
     * `std.fs.updateFileAbsolute`
    
    Moved:
     * `std.fs.Dir.UpdateFileOptions` => `std.fs.CopyFileOptions`
    
    Deprecated:
     * `std.fs.deleteDir`
     * `std.fs.deleteDirC`
     * `std.fs.deleteDirW`
     * `std.fs.readLink`
     * `std.fs.readLinkC`


commit 6ab156ce7dd781875db4965361418d8cdf4b3771
Merge: 9b1b44b41 25d9ab95d
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Mar 9 13:01:26 2020 -0400

    Merge pull request #4695 from leroycep/feature-inode-stat
    
    Expose file inode number on posix and file index on windows

commit 11df0d0cf8c786d5b502c21a42d47631657a42f4
Author: LemonBoy <thatlemon@gmail.com>
Date:   Wed Mar 11 20:56:43 2020 +0100

    std: Add setEndPos to fs.file #4716
    
    Allow the user to shrink/grow the file size as needed.

commit 27affde592653ac7f92489cec404b4bf3e0d1b29
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Mar 18 14:45:01 2020 -0400

    (breaking) clarify openDir API
    
     * remove deprecated `std.fs.Dir` APIs
     * `std.fs.Dir.openDir` now takes a options struct with bool fields for
       `access_sub_paths` and `iterate`. It's now much more clear how
       opening directories works.
     * fixed the std lib and various zig code calling the wrong openDir
       function.
     * the runtime safety check for dir flags is removed in favor of the
       cheaper option of putting a comment on the same line as handling
       EBADF / ACCESS_DENIED, since that will show up in stack traces.


     improvements to std.fs, std.os #4618

    add missing errors to std.os.windows.CreateDirectoryError
      TODO Ryan Liptak fixed std.fs.realpath/os.realpathW for directories on Windows.

     <p>
     Thank you to contributors Jonathan S, daurnimator, LemonBoy,
     dimenus, and stratact.
     </p>
    

    <h2 id="Networking"><a href="#toc-Networking">Networking</a> <a class="hdr" href="#Networking">ยง</a></h2>

    TODO explain status
commit bf16fc210bc765202489ae83e0ad1dce8d9b4e16
Author: Luna <git@l4.pm>
Date:   Sat Oct 26 22:00:50 2019 -0300

    fix std.os.accept4
    
     - add WouldBlock to list of errors in AcceptError
     - ptrCast addr_size to the system's socklen_t, instead of assuming it's
        usize



    TODO std.net.getAddressList - basic DNS address resolution for linux without libc
    std.net: port the RFC 3484/6724 destination address selection from musl libc

commit c3d816a98e1126f5de4ec1a45e5f65bb2ff2f43c
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Oct 29 22:59:30 2019 -0400

    std lib networking improvements, especially non-blocking I/O
    
     * delete the std/event/net directory
     * `std.event.Loop.waitUntilFdReadable` and related functions
       no longer have possibility of failure. On Linux, they fall
       back to poll() and then fall back to sleep().
     * add some missing `noasync` decorations in `std.event.Loop`
     * redo the `std.net.Server` API. it's quite nice now, but
       shutdown does not work cleanly. There is a race condition with
       close() that I am actively working on.
     * move `std.io.OutStream` to its own file to match `std.io.InStream`.
       I started working on making `write` integrated with evented I/O,
       but it got tricky so I backed off and filed #3557. However
       I did integrate `std.os.writev` and `std.os.pwritev` with evented I/O.
     * add `std.Target.stack_align`
     * move networking tests to `lib/std/net/test.zig`
     * add `std.net.tcpConnectToHost` and `std.net.tcpConnectToAddress`.
     * rename `error.UnknownName` to `error.UnknownHostName` within the
       context of DNS resolution.
     * add `std.os.readv`, which is integrated with evented I/O.
     * `std.os.preadv`, is now integrated with evented I/O.
     * `std.os.accept4` now asserts that ENOTSOCK and EOPNOTSUPP never
        occur (misuse of API), instead of returning errors.
     * `std.os.connect` is now integrated with evented I/O.
       `std.os.connect_async` is gone. Just use `std.os.connect`.
     * fix false positive dependency loop regarding async function frames
     * add more compile notes to help when dependency loops occur
       in determining whether a function is async.
     * ir: change an assert to ir_assert to make it easier to find
       workarounds for when such an assert is triggered. In this case
       it was trying to parse an IPv4 address at comptime.
commit 0de862e8bafce9a58c1018e9b6f81b3d17279c10
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Oct 30 19:27:42 2019 -0400

    make std.net more portable
    
     * Delete `std.net.TmpWinAddr`. I don't think that was ever meant to
       be a real thing.
     * Delete `std.net.OsAddress`. This abstraction was not helpful.
     * Rename `std.net.Address` to `std.net.IpAddress`. It is now an extern
       union of IPv4 and IPv6 addresses.
     * Move `std.net.parseIp4` and `std.net.parseIp6` to the
       `std.net.IpAddress` namespace. They now return `IpAddress` instead of
       `u32` and `std.net.Ip6Addr`, which is deleted.
     * Add `std.net.IpAddress.parse` which accepts a port and parses either
       an IPv4 or IPv6 address.
     * Add `std.net.IpAddress.parseExpectingFamily` which additionally
       accepts a `family` parameter.
     * `std.net.IpAddress.initIp4` and `std.net.IpAddress.initIp6` are
       improved to directly take the address fields instead of a weird
       in-between type.
     * `std.net.IpAddress.port` is renamed to `std.net.IpAddress.getPort`.
     * Added `std.net.IpAddress.setPort`.
     * `os.sockaddr` struct on all targets is improved to match the
       corresponding system struct. Previously I had made it a union of
       sockaddr_in, sockaddr_in6, and sockaddr_un. The new abstraction for
       this is now `std.net.IpAddress`.
     * `os.sockaddr` and related bits are added for Windows.
     * `os.sockaddr` and related bits now have the `zero` fields default
       to zero initialization, and `len` fields default to the correct size.
       This is enough to abstract the differences across targets, and so
       no more switch on the target OS is needed in `std.net.IpAddress`.
     * Add the missing `os.sockaddr_un` on FreeBSD and NetBSD.
     * `std.net.IpAddress.initPosix` now takes a pointer to `os.sockaddr`.

    canonicalize std.os IPPROTO constants

commit 2e0dd5733f9aec168f72167ca0a0e306b2810ae2
Author: Luna <git@l4.pm>
Date:   Sat Nov 2 16:46:48 2019 -0300

    add FileNotFound to os.ConnectError error set

commit d535bf2c7d22ff2039158bfa8d21bfb012a34c0c
Author: Luna <git@l4.pm>
Date:   Sat Nov 2 16:41:32 2019 -0300

    add FileNotFound error to os.connect

commit 9458620e18cb89b71cd0ad2755b9a7ae4f63e846
Author: Luna <git@l4.pm>
Date:   Fri Nov 8 19:59:30 2019 -0300

    replace Address.parse Address.parseIp

commit 5d05cfcfe6144a7f49f57cb376863edd0059d9ca
Author: Luna <git@l4.pm>
Date:   Fri Nov 8 19:35:04 2019 -0300

    rename IpAddress to Address, add Address.unix

commit 05ae21b78ed58e621fd2c10456a3f100a8107e3a
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 12:51:33 2019 -0300

    make StreamServer.listen family-agnostic
    
     - rename Address.parseUnix to Address.initUnix

commit f4d8dc278b312fc3eccf33a37cfe89c7c012d6fd
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 12:40:56 2019 -0300

    rename TcpServer -> StreamServer
    
     - add AF_UNIX support to getOsSockLen

commit 348c0232a5612eb9bdb445e80e6e201d24911dcc
Author: Luna <git@l4.pm>
Date:   Sat Nov 9 14:53:48 2019 -0300

    miscellaneous fixes
    
     - make connextUnixSocket use std.net.Address
     - fix StreamServer.listen giving wrong protocol for unix sockets

commit c8a8da28049d2e9aece857359725b2a8f6d3732b
Author: Luna <git@l4.pm>
Date:   Sun Nov 10 16:44:18 2019 -0300

    remove builtin.os check in Address.initUnix

commit d1eabe81a99c3fe6c0e551e9bab90a3bbae509fe
Author: Luna <git@l4.pm>
Date:   Sun Nov 10 14:38:33 2019 -0300

    add sockaddr_un to os/bits/windows

    Luna: std.net: add unix socket support to Address and StreamServer

commit 6e786b60d4fb3a39b717e077d034131be613d6aa
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 19:54:36 2019 +0200

    support ipv4-mapped ipv6 addresses

commit 32ac1b5927ba9314b9fa0ec2bb21dba4b2e66c66
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 18:59:14 2019 +0200

    improve ipv6 parsing and formatting

commit 6c1728206288264c4d2508a190d392ade68d115c
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Nov 4 14:39:59 2019 -0500

    std.os.read can fail with ConnectionResetByPeer

commit a26e9fa7238e972301f761db80434fa0205d1016
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Mon Nov 4 23:11:52 2019 +0200

    add special formatting for ipv4-mapped ipv6 addresses

commit aa4e92f3b3dc4b349eeabf589f8b9047e7342f03
Author: frmdstryr <frmdstryr@protonmail.com>
Date:   Mon Nov 18 08:45:25 2019 -0500

    Make StreamServer return address of accecpted client



    Luna: net: add reuse_address option to StreamServer. (#3820)


commit 778dbc17acce77588a46a27074ecb8b418786d94
Author: LemonBoy <thatlemon@gmail.com>
Date:   Tue Mar 24 19:14:01 2020 +0100

    std: Fix setsockopt definition
    
    * Add socketpair definition


     <p>
     Thank you to contributors Luna, Vexu, Jonathan Marler, Sebastian,
     and frmdstryr.
     </p>
    

    <h2 id="JSON"><a href="#toc-JSON">JSON</a> <a class="hdr" href="#JSON">ยง</a></h2>

commit a0abd3be85a6c24a913ee650e1fd51bf3f457c68
Author: xackus <14938807+xackus@users.noreply.github.com>
Date:   Sun Oct 27 10:45:54 2019 +0100

    fix json parser crashing on empty input
    remove unreachable code
    <ul>
      <li>Sebastian Keller added <code class="zig">std.json.WriteStream.writeJson</code>.</li>
      <li>Sebastian Keller fixed a leak in the json parser.</li>
      <li>Sebastian Keller: std.json.Value: added dumpStream(), utilize WriteStream for dump().</li> 
      <li>xackus improved documentation for JSON APIs, fixed unescaping of strings, as well as
      other bugs, and added more test coverage.</li> 
      <li>daurnimator improved the <code class="zig">std.json</code> API. (#4007)</li>
    </ul>
    TODO git audit this

    xackus: json: implement copy_strings=false (#4091)

commit 2933a8241a54af436f2df5eac73aa2acf5eabd40
Author: hryx <codroid@gmail.com>
Date:   Sun Jan 5 23:16:38 2020 -0800

    json: disallow overlong and out-of-range UTF-8
    
    Fixes #2379
    
    = Overlong (non-shortest) sequences
    
    UTF-8's unique encoding scheme allows for some Unicode codepoints
    to be represented in multiple ways. For any of these characters,
    the spec forbids all but the shortest form. These disallowed longer
    sequences are called "overlong". As an interesting side effect of
    this rule, the bytes C0 and C1 never appear in valid UTF-8.
    
    = Codepoint range
    
    UTF-8 disallows representation of codepoints beyond U+10FFFF,
    which is the highest character which can be encoded in UTF-16.
    Because a 4-byte sequence is capable of resulting in such characters,
    they must be explicitly rejected. This rule also has an interesting
    side effect, which is that bytes F5 to FF never appear.
    
    = References
    
    Detecting an overlong version of a codepoint could get gnarly, but
    luckily The Unicode Consortium did the hard work by creating this
    handy table of valid byte sequences:
    
    https://unicode.org/versions/corrigendum1.html
    
    I thought this mapped nicely to the parser's state machine, so I
    rearranged the relevant states to make use of it.

    

    <h2 id="Bring-Your-Own-OS-Abstraction-Layer"><a href="#toc-Bring-Your-Own-OS-Abstraction-Layer">Bring-Your-Own-OS Abstraction Layer</a> <a class="hdr" href="#Bring-Your-Own-OS-Abstraction-Layer">ยง</a></h2>

commit dcbd5ad1553c5994353de47babc0e07e02153bd8
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Dec 2 12:01:49 2019 -0500

    remove upstream support for Zen hobby OS
    
    The new plan to support hobby operating systems is #3784.
    
    And what kind of name is "Zen" anyway? There's already a
    [Zen programming language](http://zenlang.sourceforge.net/)
    and that's just confusing.
commit ad214c7aa00fc82b243eb38061f41588a0c58867
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Dec 2 15:02:17 2019 -0500

    bring your own OS layer in the std lib
    
    closes #3784

commit 10e172b1d77619469653b0521d8f65604fa549c7
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Dec 4 14:42:18 2019 -0500

    add `other` OS and fix regression in build-exe for freestanding

commit b375f6e027a159616e80906aa05e253fbe8cc9df
Author: Christine Dodrill <me@christine.website>
Date:   Wed Dec 11 18:37:52 2019 -0500

    lib/std/io: let the bring-your-own OS package handle stdio (#3887)

commit b37acc4d6870a090c3501d81d3f647bc30220e4b
Author: Christine Dodrill <me@christine.website>
Date:   Thu Dec 12 01:31:32 2019 +0000

    allow custom OS entrypoint
    
    Also:
    
     * Expose `std.start.callMain`.
     * Other fixes added to fix issues found in development.


    

    <h2 id="ArrayList"><a href="#toc-ArrayList">ArrayList</a> <a class="hdr" href="#ArrayList">ยง</a></h2>


commit c3d8b1ffebb94d180c382bd74128d17dc21c1392
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Tue Dec 10 15:08:10 2019 -0500

    remove iterator API from std.ArrayList
    
    This is not a meaningful abstraction. Use a for loop on the result
    of `toSlice` or `toSliceConst`.
    
    An iterator can be implemented on top of ArrayList by applications which
    want additional functionality, such as removing elements while
    iterating.
    
    Closes #3037.

commit 1483ae37f2dae6a5b9db1f7851cf5dc9a86e57f3
Author: Bas <BarabasGitHub@users.noreply.github.com>
Date:   Wed Feb 19 17:33:35 2020 +0100

    Add an appendValues method to ArrayList to append a value n times. (#4460)


    TODO mention deprecated API
    TODO mention std.ArrayList: make the slice field valid and public, and the capacity a separate field #4852
    TODO mention outStream()
    TODO mention daurnimator's efforts to reduce Buffer usage #4665
    TODO git shortlog for this file

    TODO Thanks xackus

    <ul>
      <li>MCRusher added <code class="zig">initCapacity</code> to <code class="zig">std.ArrayList</code> and <code class="zig">std.ArrayListSentineled</code>.</li>
    </ul>

    

    <h2 id="Memory"><a href="#toc-Memory">Memory</a> <a class="hdr" href="#Memory">ยง</a></h2>

commit 5575e2a168c07d2dcc0e58146231e490ef8a898e
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Jan 1 18:08:40 2020 -0500

    std.mem.compare: breaking API changes
    
     * `std.mem.Compare` is now `std.math.Order` and the enum tags
       renamed to follow new style convention.
     * `std.mem.compare` is renamed to `std.mem.order`.
     * new function `std.math.order`

commit 0deab8fd3bba3fa25ab70f6cf2e04b234aba8eb4
Author: Timon Kruiper <timonkruiper@gmail.com>
Date:   Mon Jan 6 21:38:11 2020 +0100

    Add std.mem.zeroes to the standard library
    
    This zero initializes the type passed in. Can be used to zero
    initialize c structs.


commit 5b26128bacddf594dfe45958a236bfa2459f878b
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 1 13:07:55 2020 -0500

    add new functions to std.mem and deprecate others
    
    add std.mem.Span
    add std.mem.span
    add std.mem.length
    add std.mem.indexOfSentinel
    
    deprecate std.mem.len
    deprecate std.mem.toSlice
    deprecate std.mem.toSliceConst

commit ef3d761da545a3a72928ed0e0ba3b749a4cb74d8
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 1 13:21:29 2020 -0500

    breaking: std.mem.len no longer takes a type argument
    
    also update fmt code to use std.mem.span.

    revert std.mem.span to prefer len over sentinel; add spanZ

commit 3be720a729e20720a033f2cf1958311a0112d1f4
Author: daurnimator <quae@daurnimator.com>
Date:   Mon Mar 30 21:56:09 2020 +1100

    std: mem span functions can take an optional pointer

commit ef419dd72d3fc9ec1454099367bd8d43f1b5037b
Author: Sebastian <15335529+Sobeston@users.noreply.github.com>
Date:   Mon Mar 30 02:57:50 2020 +0100

    mem.zeroes .Array improvements
    
    Before (when given an array with many elements):
    ```
    zig\std\mem.zig:345:13: error: evaluation exceeded 1000
    backwards branches
                for (array) |*element| {
                ^
    ```
    related to https://github.com/ziglang/zig/issues/4847#issuecomment-605721461

commit cd20e0cc672249555709e1b58a415ddd50b03ad9
Author: xackus <14938807+xackus@users.noreply.github.com>
Date:   Sat Apr 4 19:15:08 2020 +0200

    rename mem.separate to mem.split

    <ul>
      <li>Bas van den Berg made <code class="zig">std.mem.zeros</code> support more types besides
        extern structs. (#4544)</li>
      <li>Jonathan Marler added <code class="zig">std.mem.Allocator.allocSentinel</code>.</li>
    </ul>
    

    <h2 id="Crypto"><a href="#toc-Crypto">Crypto</a> <a class="hdr" href="#Crypto">ยง</a></h2>

    TODO find other crypto refs here


commit 4b86c1e3bbe65b8caa9c2e769af633fa8825bb94
Author: Jay Petacat <jay@jayschwa.net>
Date:   Sat Feb 1 22:29:51 2020 -0500

    crypto: Add BLAKE3 hashing algorithm (#4366)
    
    This is a translation of the [official reference implementation][1] with
    few other changes. The bad news is that the reference implementation is
    designed for simplicity and not speed, so there's a lot of room for
    performance improvement. The good news is that, according to the crypto
    benchmark, the implementation is still fast relative to the other
    hashing algorithms:
    
    ```
             md5: 430 MiB/s
            sha1: 386 MiB/s
          sha256: 191 MiB/s
          sha512: 275 MiB/s
        sha3-256: 233 MiB/s
        sha3-512: 137 MiB/s
         blake2s: 464 MiB/s
         blake2b: 526 MiB/s
          blake3: 576 MiB/s
        poly1305: 1479 MiB/s
        hmac-md5: 653 MiB/s
       hmac-sha1: 553 MiB/s
     hmac-sha256: 222 MiB/s
          x25519: 8685 exchanges/s
    ```
    
    [1]: https://github.com/BLAKE3-team/BLAKE3
    

    <h2 id="Start-Code"><a href="#toc-Start-Code">Start Code</a> <a class="hdr" href="#Start-Code">ยง</a></h2>

    <p>Logic involving startup code has been moved from being hard-coded in the compiler to
    <code class="zig"><span class="tok-kw">comptime</span></code> logic inside the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/lib/std/start.zig">start.zig</a>
    file from the standard library.
    </p>
    <p>
    Additionally, the startup code is un-special-cased.
    </p>
    <p>
    Previously, the compiler had special logic to determine whether to
    include the startup code, which was in <code>std/special/start.zig</code>. Now,
    the file is moved to <code>std/start.zig</code>, and there is no special logic
    in the compiler. Instead, the standard library unconditionally imports
    the <code>start.zig</code> file, which then has a <code>comptime</code> block that does the
    logic of determining what, if any, start symbols to export. Instead of
    <code>start.zig</code> being in its own special package, it is just another normal
    file that is part of the standard library.
    </p>
    <p>
    <code>std.builtin.TestFn</code> is now part of the standard library rather than
    specially generated by the compiler.
    </p>
    <p>
    Additionally, some minor changes to Thread-Local Storage handling (#4807):
    </p>
    <ul>
      <li>Always allocate an info block per-thread so that libc can store important stuff there.</li>
      <li>Respect ABI-mandated alignment in more places.</li>
      <li>Nicer code, use slices/pointers instead of raw addresses whenever possible.</li>
    </ul>
    <p>Thanks to LemonBoy, Vexu, Jared Miller, and Nick Erdmann for contributions related to this.</p>
    

    

    <h1 id="Documentation"><a href="#toc-Documentation">Documentation</a> <a class="hdr" href="#Documentation">ยง</a></h1>

    <ul>
      <li>Language reference updated to take into account <a href="#Language-Changes">Language Changes</a>.</li>
      <li>Language reference makes it more obvious that <code class="zig"><span class="tok-kw">if</span></code> is an expression.</li>
      <li>New section: <a href="https://ziglang.org/documentation/0.6.0/#Function-Parameter-Type-Inference">Function Parameter Type Inference</a></li>
      <li>Clarify <code class="zig"><span class="tok-kw">allowzero</span></code> interaction with optional pointers.</li>
      <li>Language reference has table of contents in a separate column on large displays.</li>
    </ul>
    <p>
    Thanks to Vexu, xackus, LemonBoy, data-man, Benjamin Feng, Emilio G. Cota,
    Jonathan Marler, MateuszOkulus, Matt Keeter, Maximilian Hunt, Nathan Michaels,
    Nick Erdmann, Robin Voetter, Shritesh, hryx, momumi, and yvt for contributions
    to the language reference.
    </p>

    <h2 id="Documentation-Generation"><a href="#toc-Documentation-Generation">Documentation Generation</a> <a class="hdr" href="#Documentation-Generation">ยง</a></h2>

    <p>This feature is still experimental.</p>
    <p>There is a new <code>-fdump-analysis</code> command line option, which creates
    a <code>$NAME-analysis.json</code> file with all of the finished
    semantic analysis that the stage1 compiler produced.
    It contains types, packages, declarations, and files.</p>
    <p>
    This feature can be used to power IDE integration features until such time
    as the self-hosted compiler is available and supports such features more directly.
    </p>
    <p>
    Additionally, there is a proof-of-concept documentation generation feature (#21):
    </p>
    <p>The new <code>-femit-docs</code> CLI option outputs:
    <ul>
      <li>doc/index.html</li>
      <li>doc/data.js</li>
      <li>doc/main.js</li>
    </ul>
    <p>
    In this strategy, we have 1 static html page and 1 static javascript
    file, which loads the semantic analysis dump directly and renders it
    using DOM manipulation.
    </p>
    <p>
    There is now
    <a href="https://ziglang.org/documentation/0.6.0/std/">experimental std lib documentation</a>.
    </p>
    <p>
    There are still some missing features. For example, it does not handle generic types ideally,
    multiple packages are not handled well, and some URLs are broken. Additionally, the
    <a href="https://github.com/ziglang/zig/blob/0.6.0/tools/merge_anal_dumps.zig">merge_anal_dumps tool</a>
    is not yet complete, so generated documentation can only apply to a single build configuration.
    For example, if the generated docs targeted Windows, then Linux-only functions will not be
    shown in the documentation, and vice-versa. Due to Zig's lazy analysis many declarations
    are not semantically analyzed, causing them to be omitted in the generated documentation.
    These are all open issues to be addressed.
    </p>
    <p>
    Despite the flaws it can still be a useful way to explore the <a href="#Standard-Library">Standard Library</a>.
    It has motivated some contributions to improve doc comments to various APIs:
    </p>
    <ul>
      <li>Felix Queiรner added documentation for std.fmt.format grammar and customization. (#3474)</li>
      <li>Nathan Michaels added docs for ArrayList, failing_allocator, and Allocator. (#3540)</li>
      <li>Nathan Michaels documented std.Mutex.</li>
      <li>Nathan Michaels documented PriorityQueue.</li>
      <li>Josh Wolfe added documentation for mutable HashMap KV pointers.</li>
      <li>Felix (xq) Queiรner added documentation to <code class="zig">std.atomic.Queue</code>.</li>
    </ul>
    <p>
    Thank you Rocknest, Timon Kruiper, Henry Wu, Felix Queiรner, Vexu, dtw-waleee,
    pfg, and xackus for related contributions.
    </p>
    
    

    <h1 id="Safety"><a href="#toc-Safety">Safety</a> <a class="hdr" href="#Safety">ยง</a></h1>

    TODO Resuming non-suspended functions now has runtime safety. #3469
    

    <h1 id="zig-build"><a href="#toc-zig-build">zig build</a> <a class="hdr" href="#zig-build">ยง</a></h1>

    <p>
    <code>zig build</code> is still in an experimental, proof-of-concept phase, and will remain
    that way until at least the <a href="#Package-Manager-Status">package manager</a> is complete.
    Nonetheless, there were plenty of improvements to <code>zig build</code> this release cycle:
    </p>
    <p>
    The most notable changes to zig build have to do with the new <a href="#Target-Details">Target Details</a>.
    See that section for how to use the new <code class="zig">setTarget</code> API.
    </p>
    <p>
    One new trick that may be useful to Windows developers is to set the default target to be
    <code>native-native-gnu</code>. This will use the native
    <a href="#OS-Version-Ranges">OS and version range</a> as well as the
    <a href="#CPU-Features">native CPU</a>, but take advantage of
    <a href="#mingw-w64-700">mingw-w64</a> rather than trying to integrate with system MSVC.
    This is more likely to "just work" for all your project contributors,
    because it eliminates a problematic system dependency.
    </p>
    <p>
    Additionally the following improvements were made:
    </p>
    <ul>
      <li>Bumped default max exec output size to 400 KB. (#3415)</li>
      <li><code class="zig">addIncludeDir</code> does <code>-I</code> instead of <code>-isystem</code>.</li>
      <li>Initial support for using vcpkg libraries. However it is
        <a href="https://github.com/ziglang/zig/issues/4510">not integrated automatically yet</a>.</li>
      <li>Fixed failure to recognize the PATH environment variable due to
          incorrectly treating the environment variable as case sensitive on Windows.</li>
      <li>Rework and improve some of the zig build steps<ul>
          <li> RunStep gains ability to compare
       output and exit code against expected values. Multiple redundant
       locations in the test harness code are replaced to use RunStep.</li>
       <li> WriteFileStep gains
       ability to write more than one file into the cache directory, for
       when the files need to be relative to each other. This makes
       usage of WriteFileStep no longer problematic when parallelizing
       zig build.</li>
       <li> Added CheckFileStep, which can be used to validate that the output
       of another step produced a valid file. Multiple redundant locations
       in the test harness code are replaced to use CheckFileStep.</li>
       <li> Added TranslateCStep. This exposes zig translate-c to the build
       system, which is likely to be rarely useful by most Zig users;
       however Zig's own test suite uses it both for translate-c tests and
       for run-translated-c tests.</li>
       <li> Refactored ad-hoc code to handle source files coming from multiple
         kinds of sources, into std.build.FileSource.</li>
       <li> Added std.build.Builder.addExecutableFromWriteFileStep.</li>
       <li> Added std.build.Builder.addExecutableSource.</li>
       <li> Added std.build.Builder.addWriteFiles.</li>
       <li> Added std.build.Builder.addTranslateC.</li>
       <li> Added std.build.LibExeObjStep.addCSourceFileSource.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileFromWriteFileStep.</li>
       <li> Added std.build.LibExeObjStep.addAssemblyFileSource.</li>
      </ul></li>
      <li><code>--</code> can be used to pass args to zig build commands.</li>
      <li><code>-D</code> now supports "list" type options.</li>
      <li>Nesting package dependencies is now supported.</li>
      <li>InstallRawStep is available to do a similar job to objcopy. It can be
        used with <code class="zig">exe.installRaw(<span class="tok-str">&quot;kernel.bin&quot;</span>);</code> where exe is a LibExeObjStep. (#2826)</li>
      <li>zig build now correctly handles multiple output artifacts (#4733, #4735)<br>
    Previously the zig build system incorrectly assumed that the only build
    artifact was a binary. Now, when you enable the cache, only the output
    dir is printed to stdout, and the zig build system iterates over the
    files in that directory, copying them to the output directory.</li>
      <li>-ffunction-sections switch exposed to zig build scripts.</li>
      <li>The default stdin behavior of RunStep is now .Inherit. Since this is a breaking change,
        previous behavior can be restored by doing: <code class="zig">RunStep.stdin_behavior = .Ignore</code>.</li>
      <li>Configuring the subsystem is exposed to build scripts.</li>
    </ul>
    <p>
    Thanks to Benjamin Feng, David Cao, Layne Gustafson, LemonBoy, Michael Dusan,
    Michaรซl Larouche, Nick Erdmann, Noam Preil, Sahnvour, Timon Kruiper,
    Valentin Anger, dbandstra, emekoi, frmdstryr, meme, mogud, pwzk, stratact,
    syscall0, and xackus for related contributions.
    </p>
    

    <h1 id="zig-fmt"><a href="#toc-zig-fmt">zig fmt</a> <a class="hdr" href="#zig-fmt">ยง</a></h1>

    <p>TODO</p>
commit 7495fd8cb9eea3d571ec62eff069b443ac0e3a6a
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Tue Oct 15 14:06:08 2019 +0300

    fix struct align fmt
commit 7277670843d259d19093c8900b1f8445e41202ae
Author: shiimizu <shiimizu@protonmail.com>
Date:   Thu Oct 31 10:23:02 2019 -0700

    Add error when too few arguments are provided to std.fmt

commit 10cc8cad86a39dd0f6d707c3ec30f490ba071230
Author: Vexu <git@vexu.eu>
Date:   Thu Dec 5 14:45:36 2019 +0200

    fix zig fmt of c pointers



    LemonBoy: Trailing comma is respected for builtin calls.

    <p>
    Thanks to LemonBoy, Vexu, Robin Voetter, Brendan Hansknecht, Michael Raymond, and xackus
    for contributions to <code>zig fmt</code>.
    </p>
    

    <h1 id="zig-cc"><a href="#toc-zig-cc">zig cc</a> <a class="hdr" href="#zig-cc">ยง</a></h1>

    TODO explain zig cc, zig c++. link to the blog post.
    TODO explain how production ready is it
    TODO mention follow up issues
    TODO mention https://github.com/nim-lang/Nim/pull/13757


    TODO use -fsanitize=undefined for C code in safe build modes closes #3569

    expose the ability to disable C sanitization
    
    and disable C sanitization when building libcs.
    Empirically, they seem to trigger undef-sanitization.


    improved handling of native system directories
    
     * `-isystem` instead of `-I` for system include directories
       fixes a problem with native system directories interfering with zig's
       bundled libc.


commit 6408766d6b55d228a305b877f28f45c1587f7d39
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Mar 30 15:50:53 2020 -0400

    linking: remove check for target_supports_libunwind
    
    I'm not sure why this was ever there. Maybe it was working around a
    problem with LLVM 9. Anyway this fixes linking C++ code for 32 bit
    arm and riscv.

    <p>
    Zig introduces support for drop-in replacement of GCC/Clang toolchains in blog post
    <a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html">here</a> .
    </p>
    New sub-commands <code>zig cc</code> and <code>zig c++</code> provide
    command-line compatibility with the corresponding GCC/Clang drivers.
    </p>
    <p>
    Zig translates the semantics of the arguments to its own internal build logic.
    Clang options that Zig is not aware of are forwarded to Clang directly.
    Some parameters are handled specially.
    </p>
    <p>
    Thank you to Michael Dusan and Ryan Liptak for contributions related to this feature.
    </p>
    

    <h1 id="libc"><a href="#toc-libc">libc</a> <a class="hdr" href="#libc">ยง</a></h1>

    <p>TODO</p>

    <h2 id="musl-120"><a href="#toc-musl-120">musl 1.2.0</a> <a class="hdr" href="#musl-120">ยง</a></h2>

    <p>
    Zig ships with the source code to <a href="https://www.musl-libc.org/">musl</a>.
    When the musl C ABI is selected, Zig builds musl from source for the selected target.
    </p>
    <p>
    This release updates the bundled musl source code to
    <a href="https://musl.libc.org/releases.html">v1.2.0</a>.
    </p>
    <p>
    With this release, Zig no longer has any patches against upstream.
    </p>
    

    <h2 id="glibc-231"><a href="#toc-glibc-231">glibc 2.31</a> <a class="hdr" href="#glibc-231">ยง</a></h2>

    <p>
    Zig gains the ability to target
    <a href="https://sourceware.org/legacy-ml/libc-announce/2020/msg00001.html">glibc 2.31</a>
    in addition to the other 41 glibc versions.
    </p>

    TODO include ld symbols when generating glibc dummy objects closes #4748
    TODO add libutil to zig's glibc support
    

    <h2 id="mingw-w64-700"><a href="#toc-mingw-w64-700">mingw-w64 7.0.0</a> <a class="hdr" href="#mingw-w64-700">ยง</a></h2>

    <p>
    Zig ships with the source code to <a href="https://mingw-w64.org/">mingw-w64</a>.
    When targeting *-windows-gnu and linking against libc, Zig builds mingw-w64 from source
    for the selected target.
    </p>
    <p>
    This release updates the bundled mingw-w64 source code to
    <a href="https://sourceforge.net/p/mingw-w64/mailman/message/36804945/">v7.0.0</a>.
    </p>
    TODO
commit 5aa281250723c159aa0429941c16b046bba6d316
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 29 13:17:21 2020 -0400

    linking is now aware -lm is provided by mingw-w64

commit 701c03d083c4d57275d95e921f03184515e0d247
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Apr 5 19:39:28 2020 -0400

    zig uses mingw-w64 to provide -lpsapi

commit 28d96966174e0cd38133ca2885240c9825a384f9
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Apr 5 19:32:37 2020 -0400

    use mingw-w64 to provide -luuid if requested

commit b3aef49eeaa42127ac57ded3b15228db39f806b3
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Apr 8 01:21:00 2020 -0400

    zig provides shlwapi.lib for *-windows-gnu
    
    closes #3711
    
    

    <h1 id="C-Translation"><a href="#toc-C-Translation">C Translation</a> <a class="hdr" href="#C-Translation">ยง</a></h1>

    <p>TODO talk about Vexu</p>
    <p>TODO talk about effort to self host it, C API wrapper, and it's done now</p>
    <p>TODO mention that vexu made a c tokenizer and as a result macro support is much better</p>
    <p>TODO mention that the c tokenizer and c ast parser are in the std lib</p>
    related issue: #1964
    note that it shaved 5 seconds off the build time of zig
commit d04c58816d673208aae476e1cc2d223a26604c45
Author: Timon Kruiper <timonkruiper@gmail.com>
Date:   Thu Oct 24 15:57:34 2019 +0200

    Translate-c: Fix a segfault when to many errors are emitted
    
    This was already fixed when doing `@cImport`, but not yet when
    running `zig translate-c`.

commit ed956b581283824da1f7d39b953f4d716928eee2
Author: daurnimator <quae@daurnimator.com>
Date:   Sun Nov 17 16:18:18 2019 +1100

    translate-c: add support for MacroQualified definitions

commit 69dee57d95271169898f8382f7e4846bf77a0040
Author: Vexu <git@vexu.eu>
Date:   Thu Dec 12 14:26:24 2019 +0200

    remove concept of translate mode

    mention run-translated-c tests

commit cbfd66f68a5a390abcf99e8cc6923d056ee1e4fa
Author: LemonBoy <thatlemon@gmail.com>
Date:   Mon Dec 30 12:17:52 2019 +0100

    Don't crash when parsing invalid files

    ^ related: mention the (still ongoing) clang API problem
    related: commit below:
commit 5e37fc0746a75ed319fc57ae62d8cc966382c592
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Feb 16 01:45:48 2020 -0500

    more user-friendly error message for some clang diagnostics
    
    See #4455



    There is now a build.zig step for translate-c

    translate-c supports caching so subsequent builds are fast


    add "Improving Translate-C" section to CONTRIBUTING.md

    <p>
    Additional thanks to LemonBoy, Merlyn Morgan-Graham, Feix Weiglhofer,
    Josh Wolfe, Lachlan Easton, Layne Gustafson, Michael Dusan, Rocknest,
    Tadeo Kondrak, frmdstryr, travisstaloch, and via for contributions
    related to this feature.
    </p>

    

    <h1 id="Self-Hosted-Compiler-Progress"><a href="#toc-Self-Hosted-Compiler-Progress">Self-Hosted Compiler Progress</a> <a class="hdr" href="#Self-Hosted-Compiler-Progress">ยง</a></h1>

    <p>TODO</p>
    TODO thanks Vexu for helping with the bitrot
commit b92f42d1f4b91bb343558f72af84ea052da4ac98
Author: Vexu <15308111+Vexu@users.noreply.github.com>
Date:   Sat Oct 12 12:38:09 2019 +0300

    implemented container doc comments in stage 2

    TODO self-hosted tokenizer handles \r in string literals

commit 7c1dbfab724291b492be5e64fd93ec14e48b202c
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Dec 11 02:08:33 2019 -0500

    self-hosted: manually parse args

    Vexu: add default initializers to all ast.Node base values
    xackus: stage2 parser: fix segfault on extern block (#3957)


    `zig targets` is now self-hosted

commit eff50abce68ffc69d236fcc0b919bc63fcd0e89a
Author: pwzk <pwzk@mailbox.org>
Date:   Fri Feb 7 13:40:52 2020 +0000

    Fixing library search path

commit 4b02a39aa93b0043f05de0d90443051c019643ab
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Feb 16 13:25:30 2020 -0500

    self-hosted libc detection
    
     * libc_installation.cpp is deleted.
       src-self-hosted/libc_installation.zig is now used for both stage1 and
       stage2 compilers.
     * (breaking) move `std.fs.File.access` to `std.fs.Dir.access`. The API
       now encourages use with an open directory handle.
     * Add `std.os.faccessat` and related functions.
     * Deprecate the "C" suffix naming convention for null-terminated
       parameters. "C" should be used when it is related to libc. However
       null-terminated parameters often have to do with the native system
       ABI rather than libc. "Z" suffix is the new convention. For example,
       `std.os.openC` is deprecated in favor of `std.os.openZ`.
     * Add `std.mem.dupeZ` for using an allocator to copy memory and add a
       null terminator.
     * Remove dead struct field `std.ChildProcess.llnode`.
     * Introduce `std.event.Batch`. This API allows expressing concurrency
       without forcing code to be async. It requires no Allocator and does
       not introduce any failure conditions. However it is not thread-safe.
     * There is now an ongoing experiment to transition away from
       `std.event.Group` in favor of `std.event.Batch`.
     * `std.os.execvpeC` calls `getenvZ` rather than `getenv`. This is
       slightly more efficient on most systems, and works around a
       limitation of `getenv` lack of integration with libc.
     * (breaking) `std.os.AccessError` gains `FileBusy`, `SymLinkLoop`, and
       `ReadOnlyFileSystem`. Previously these error codes were all reported
       as `PermissionDenied`.
     * Add `std.Target.isDragonFlyBSD`.
     * stage2: access to the windows_sdk functions is done with a manually
       maintained .zig binding file instead of `@cImport`.
     * Update src-self-hosted/libc_installation.zig with all the
       improvements that stage1 has seen to src/libc_installation.cpp until
       now. In addition, it now takes advantage of Batch so that evented I/O
       mode takes advantage of concurrency, but it still works in blocking
       I/O mode, which is how it is used in stage1.

commit 2f9c5c0644dd516ec0d96f33333a35e6b4deea91
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Feb 17 15:23:59 2020 -0500

    self-host dynamic linker detection

    

    <h1 id="compiler-rt"><a href="#toc-compiler-rt">compiler-rt</a> <a class="hdr" href="#compiler-rt">ยง</a></h1>

    <p>
    compiler-rt is the library that provides, for example, 64-bit integer multiplication for
    32-bit architectures which do not have a machine code instruction for it.
    In the <a href="https://gcc.gnu.org/">GNU</a> world, it's called libgcc.
    </p>
    <p>
    Unlike most compilers, which depend on a binary build of compiler-rt being installed alongside
    the compiler, Zig builds compiler-rt on-the-fly, from source, as needed for the target platform.
    This release saw some improvements to Zig's compiler-rt implementation.
    </p>
    TODO make note of LemonBoy's epic bug sleuthing
    <ul>
      <li>TODO do a git shortlog on the files</li>
      <li>LemonBoy modified compiler_rt and freestanding libc to be built with optimizations, even
      when used by Debug Mode Zig code.</li>
    </ul>
    <p>
    With Zig 0.6.0, compiler-rt is much more complete, but not fully. There are some
    <a href="https://github.com/ziglang/zig/issues/1290">missing functions</a>,
    and it's planned to do <a href="https://github.com/ziglang/zig/issues/1504">an audit</a>
    before 1.0.
    </p>
    

    <h1 id="Test-Coverage"><a href="#toc-Test-Coverage">Test Coverage</a> <a class="hdr" href="#Test-Coverage">ยง</a></h1>

    <p>TODO</p>
    <p>TODO during this release cycle zig gained aarch64 test coverage</p>
    TODO note that many bugs were discovered to have been fixed on accident, and
    regression test cases were added for them.

    mention run-translated-c tests


commit 4d134a01f5a8baae346783f19d9b5db8c8256d32
Author: Benjamin Feng <benjamin.feng@glassdoor.com>
Date:   Wed Jan 29 12:21:29 2020 -0600

    Move debug.global_allocator to testing.allocator

    note about std.testing.allocator and how it leak checks and stuff
    it found leaks in std and he fixed them

    daurnimator helped migrate more tests to use testing allocator


commit 058f38220afecb96d115143f8888496162029aed
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Thu Feb 13 16:56:26 2020 -0500

    enable passing freebsd tests
    
    See #3210 and #4455

commit 64365bc5d7b1e2c507806ee8976acc3479ad7862
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Mon Feb 17 00:06:19 2020 -0500

    enable behavior and std lib tests for RISC-V 64-bit
    
    closes #3338


commit c70471fae617fb91ca0a323f079574a3caaa7775
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Sun Mar 29 10:33:37 2020 -0400

    enable now-passing test cases
    
    These can now be enabled thanks to bug fixes that landed in
    LLVM 10.


      <p>Michael Dusan figured out how to produce a static binary tarball of QEMU, allowing
        the CI server to use a newer QEMU version, allowing more test coverage of SIMD.</p>

    

    <h1 id="Memory-Usage-Reduction"><a href="#toc-Memory-Usage-Reduction">Memory Usage Reduction</a> <a class="hdr" href="#Memory-Usage-Reduction">ยง</a></h1>

    <p>
    The large portion of Zig compiler that is (currently) implemented in C++ is memory
    hungry and our continuous-integration process exacerbates the issue to the point
    where the RAM/VRAM sizes of open-source CI providers are sometimes insufficient.
    Additionally as we add more features and tests, yet more memory pressure is applied.
    </p>
    <p>
    The following bits are related to reducing the max RSS footprint of the compiler.
    Implementations by Andrew Kelley (ak) and Michael Dusan (md).
    </p>
    <ul>
      <li>(ak)
        Zig driver built with <code>-DZIG_ENABLE_MEM_PROFILE</code> accepts
        command-line option -fmem-report to produce a list of objects
        allocated by compiler code. Some useful invocations:
        <ul>
            <li><code>./zig test ../lib/std/std.zig --cache off -fmem-report</code></code></li>
            <li><code>/usr/bin/time -v ./zig test ../lib/std/std.zig --cache off -fmem-report</code></li>
        </ul>
        Reduce the size of <code>IrInstruction</code> by 8 bytes on 64 bit targets.
        (#3482) RSS savings of ~3%
      </li>
      <li>(md)
        Unembed <code>ZigValue</code> from <code>IrInstruction</code>.
        Add const interning for 1-possible-value types.
        (#3502) RSS savings of ~6%
      </li>
      <li>(ak)
        Sometimes free stuff from Zig IR pass 1.
        RSS savings of ~6%
      </li>
      <li>(ak)
        Inline <code>ConstGlobalRefs</code> into <code>ZigValue</code>.
        (#3817) RSS savings of ~1.1%
      </li>
      <li>(ak)
        Free <code>IrAnalyze</code> sometimes.
        RSS savings of ~1%
      </li>
      <li>(ak)
        Split <code>IrInstruction</code> into <code>IrInst</code>, <code>IrInstSrc</code>, <code>IrInstGen</code>.
        This makes it so that less memory is used for IR instructions, as well
        as catching bugs when one expected one kind of instruction and received
        the other.
        (#4290)
      </li>
      <li>(md)
        Overhaul C++ memory allocation:
        <ul>
          <li>new <code>mem::Allocator</code> interface</li>
          <li>new <code>heap::CAllocator</code> impl with global <code>heap::c_allocator</code></li>
          <li>new <code>heap::ArenaAllocator</code> impl</li>
          <li>new <code>mem::List</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>new <code>mem::HashMap</code> takes explicit <code>Allocator&</code> parameter</li>
          <li>add <code>Codegen.pass1_arena</code> and use for all <code>ZigValue</code> allocs</li>
          <li>deinit <code>Codegen.pass1_arena</code> early in <code>zig_llvm_emit_output()</code></li>
        </ul>
        (#4389) RSS savings of ~13-15%
      </li>
      <li>(md)
        Free more heap after analysis.
        (#4515) RSS savings of ~5.5-6.3%
      </li>
    </ul>
    <p>
    The main goal of memory usage reduction is to ensure that
    <a href="#Bootstrap-Tarball">bootstrapping</a> takes 3.5 GiB or less
    on the host system (<a href="https://github.com/ziglang/zig/issues/471">#471</a>).
    </p>
    

    <h1 id="Advanced-IR-Debugging"><a href="#toc-Advanced-IR-Debugging">Advanced IR Debugging</a> <a class="hdr" href="#Advanced-IR-Debugging">ยง</a></h1>

    Andrew added native-debug helper functions for the Zig compiler.
    <p>
    Print triplet of (source:line:col) by calling member function <code>src()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump IR segment by calling member function <code>dump()</code> for types
    <code>IrExecutable{Src,Gen}</code>,
    <code>AstNode</code>,
    <code>IrInst</code>,
    <code>IrInst{Src,Gen}</code> .
    </p>
    <p>
    Dump <code>ZigValue</code> type-as-string by calling member function <code>Dump</code> .
    </p>
    <p>
    When <code>--verbose-ir</code> is enabled,
    call <code>dbg_ir_break(src_file_zig, line)</code> to breakpoint inside <code>ir_analyze()</code> .
    </p>
    <p>
    Call <code>dbg_ir_clear()</code> to clear all breakpoints.
    </p>
    

    <h1 id="Command-Line-Interface"><a href="#toc-Command-Line-Interface">Command Line Interface</a> <a class="hdr" href="#Command-Line-Interface">ยง</a></h1>

    TODO mention the transition to -femit-foo

    TODO look at git shortlog for main.cpp to thank more contributors

commit c664692bdd62765ab444a79a8704d2161c1809f1
Author: Andrew Kelley <andrew@ziglang.org>
Date:   Wed Feb 19 01:24:34 2020 -0500

    make the CLI support depending on system headers and libraries
    
    (include and lib search paths)
    
    The detection of native system paths is self-hosted.
    
    closes #2041


    TODO show when you pass a bad cpu feature or cpu model 


    <p>Thanks to Noam Preil for contributions related to this.</p>
    

    <h1 id="Miscellaneous-Improvements"><a href="#toc-Miscellaneous-Improvements">Miscellaneous Improvements</a> <a class="hdr" href="#Miscellaneous-Improvements">ยง</a></h1>

    <ul>
      <li>Add <code>-I</code> command line parameter.</li>
      <li>POSIX terminals now have a progress indicator when compilation takes a long time.
        Thanks to Luna for the initial implementation.</li>
      <li>Michael Dusan added linux XDG Base Directory integration to the cache system. #3573</li> 
      <li>Add compiler note for bad int coercion (#3724)</li>
      <li>Private linkage for unnamed internal constants.</li>
      <li>Vexu implemented better support for extern enums.</li>
      <li>LemonBoy added a compile error for @bitCast to enum types, preventing invalid enum values.</li>
      <li>David Cao added <code>--eh-frame-hdr</code> CLI option. (#3981)</li>
      <li>LemonBoy improved debug info type sizes, making debuggers happy
        and no longer report incorrect values for <code class="zig"><span class="tok-type">bool</span></code>. (#2685)</li>
      <li>LemonBoy improved the compiler to not special case the <code class="zig"><span class="tok-str">&quot;builtin&quot;</span></code>
        import with regards to <code class="zig"><span class="tok-kw">usingnamespace</span></code>.</li>
      <li>Michael Dusan improved the compiler to strip cwd from compile error paths. (#4138)</li>
      <li>Michael Dusan improved the BREAKPOINT util within the C++ compiler code to support
        non-x86 architectures.</li>
      <li>LemonBoy improved the C++ compiler code internal debugging utilities.</li>
      <li>There is no longer a <code>native_libc.txt</code> file in zig-cache, and thus
        there is no longer a possibility for this file to become stale and cause problems.
        The libc installation path detection code is always run when needed. (#3975, #4186, #4940)</li>
      <li>Michael Dusan improved the development process on POSIX to support <code>make</code> without
        being required to <code>make install</code>. On Windows the INSTALL target is still a
        required part of the development process.</li>
      <li>LemonBoy improved <code class="zig"><span class="tok-builtin">@tagName</span></code> to work on enum literals. (#4214)</li>
      <li>Valentin Anger added support for code model selection.</li>
      <li>Michael Dusan improved debuggability of the compiler by showing "Const" IR instructions
          trailing after they are referenced. (#4511)</li>
      <li>LemonBoy implemented safety checks for shl/shr when the integer size is not a power-of-two. (#2096)</li>
      <li>daurnimator removed unused static_crt_dir field from <code>zig libc</code> config.</li>
      <li>Bodie Solomon improved Zig's cmake build script to use appropriate compiler flags when
      building with MSVC. (#4877)</li>
      <li>Michael Dusan added a compiler flag to Zig's C++ compiler code that makes accidental
        switch case fallthrough a compile error, which uncovered a bug in the tokenizer.</li>
      <li>The <code>zig BUILD_INFO</code> hack is removed. 
        Rather than stuffing configuration information into the Zig binary, the
        build script reads it from config.h. This solves a problem for package
        maintainers and improves the use case of deterministic builds. (#3758)</li>
      <li>libc installation detection can correctly detect MSVC libc even when the compiler is
        built using the gnu target triple (taking advantage of <a href="#mingw-w64-700">mingw</a></li>
      <li>Tse contributed DragonFlyBSD Support.</li>
    </ul>
    

    <h1 id="Bug-Fixes"><a href="#toc-Bug-Fixes">Bug Fixes</a> <a class="hdr" href="#Bug-Fixes">ยง</a></h1>

    <p>
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aclosed+is%3Aissue+label%3Abug+milestone%3A0.6.0+">Full list of bug reports closed during this release cycle</a>.
    Note: many bugs were both introduced and resolved within this release cycle.
    Listed below are fixed bugs that were not reported on the issue tracker.
    </p>
    <p>
    Special thanks to LemonBoy, who solved a sizeable chunk of those issues, in
    many different parts of the Zig project.
    </p>
    <ul>
      <li>Better debug info for integers. Now we use ABI size * 8 instead of size_in_bits which makes
        gdb work instead of hang for non-power-of-two integers.</li>
      <li>LemonBoy fixed user-defined function alignment not getting propagated to LLVM IR.</li>
      <li>LemonBoy fixed crash when generating constant unions with single field.</li>
      <li>Various fixes related to 32-bit architectures.</li>
      <li>Async function recursion is detected and compile error emitted.</li>
      <li>Brendan Hansknecht fixed parsing of <code class="zig">.*=</code>.</li>
      <li>Vexu fixed NodeErrorSetDecl rendering.</li>
      <li>Timon Kruiper added a compile error for an empty switch on a integer.</li>
      <li>Quetzal Bradley implemented correct buffer wrapping logic in <code class="zig">std.event.Channel</code>.</li>
      <li>LemonBoy fixed WinMain not having its calling convention type-checked.</li>
      <li>xackus fixed integers parsed as floats.</li>
      <li>emekoi fixed Windows dynamic library loading and added loading for Darwin.</li>
      <li>ForLoveOfCats fixed a memory leak in <code class="zig">std.math.big.Int.toString</code>. (#3992)</li>
      <li>LemonBoy improved the compiler's type resolution phase to catch more errors.</li>
      <li>daurnimator fixed an off-by-one error in Windows process creation.</li>
      <li>LemonBoy added missing validation for <code class="zig"><span class="tok-kw">switch</span></code> range endpoints. (#4172)</li>
      <li>Vexu fixed a crash when parsing a multiline library name.</li>
      <li>Michaรซl Larouche fixed <code class="zig">std.child_process.ChildProcess.spawnWindows</code> when looking in <code class="zig">PATH</code> environment variable, it applied cwd+app_name instead of just using the app_name.</li>
      <li>daurnimator fixed bug in <code class="zig">std.http.headers</code> where .put captures user-held variable.</li>
      <li>Fixed automatically created local variables sometimes having incorrect alignment.</li>
      <li>LemonBoy fixed an edge case in <code class="zig">isAbsolute</code> path functions. Empty
      strings are no longer considered absolute paths. (#4382)</li>
      <li>Rocknest fixed a double close in <code class="zig">openElfDebugInfo</code>.</li>
      <li>Fixed not checking type of return pointers. (#3224, #3269, #3327, #3422, #3646)</li>
      <li>std lib updated to integrate with libc for environment variables, even
        when building a static library. (#3511)</li>
      <li>J.W fixed logic and index out of bounds in hashing algorithms.</li>
      <li>Exported variables now respect linkage.</li>
      <li>Alexandros Naskos fixed slicing of C pointers to no longer produce <code class="zig"><span class="tok-kw">allowzero</span></code> slices. Instead they insert a runtime assertion. (#4462)</li>
      <li>Alexandros Naskos improved made the std lib VDSO code more robust and it now operates successfully inside Windows Subsystem for Linux. (#3997)</li>
      <li>LemonBoy improved arrray subscripts to properly type coerce to <code class="zig"><span class="tok-type">usize</span></code>. (#4169)</li>
      <li>LemonBoy implemented a compile error for comparison between enum literal and untagged enum. (#4770)</li>
      <li>xackus fixed an overflow in <code class="zig">std.fmt.parseFloat</code> (#4845)</li>
      <li>Michaรซl Larouche fixed adler32 returning incorrect value with large input.</li>
      <li>LemonBoy improved big-endian compatibility. (#4935)</li>
      <li>Zig no longer caches the results of native system libc detection into a native_libc.txt file.
          Instead, it always runs native libc detection when it needs to know native libc paths. (#4772)</li>
    </ul>

    <h2 id="This-Release-Contains-Bugs"><a href="#toc-This-Release-Contains-Bugs">This Release Contains Bugs</a> <a class="hdr" href="#This-Release-Contains-Bugs">ยง</a></h2>

    <p>
    Zig has
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Abug">known bugs</a>
    and even some
    <a href="https://github.com/ziglang/zig/issues?q=is%3Aopen+is%3Aissue+label%3Amiscompilation">miscompilations</a>.
    </p>
    <p>Zig is immature. Even with Zig 0.6.0, working on a non-trivial project using Zig will
    likely require participating in the development process.</p>
    <p>The first release to ship with no known bugs will be 1.0.0.</p>
    
    

    <h1 id="Please-Welcome-Vexu-to-the-Core-Zig-Team"><a href="#toc-Please-Welcome-Vexu-to-the-Core-Zig-Team">Please Welcome Vexu to the Core Zig Team</a> <a class="hdr" href="#Please-Welcome-Vexu-to-the-Core-Zig-Team">ยง</a></h1>

    <p>I am pleased to announce our newest Zig team member, <a href="https://vexu.eu/">Vexu</a>.</p>
    <p>Vexu has shown continued dedication and discipline in contributions to the Zig
    programming language project. The quality of Vexu's work speaks for itself.</p>
    <p>
    In addition, Vexu has proven to be a steadfast community leader,
    setting an example for how to treat others with kindness and respect.
    </p>
    <p>I look forward to working with Vexu as we continue to push Zig toward 1.0.0 and beyond.</p>
    

    <h1 id="Roadmap"><a href="#toc-Roadmap">Roadmap</a> <a class="hdr" href="#Roadmap">ยง</a></h1>

    <p>TODO</p>

    <h2 id="Package-Manager-Status"><a href="#toc-Package-Manager-Status">Package Manager Status</a> <a class="hdr" href="#Package-Manager-Status">ยง</a></h2>

    <p>TODO</p>
    

    <h2 id="C-Header-File-Generation-Status"><a href="#toc-C-Header-File-Generation-Status">C Header File Generation Status</a> <a class="hdr" href="#C-Header-File-Generation-Status">ยง</a></h2>

    TODO Sahnvour improved support for exporting variables (#3284)
    TODO it's now disabled by default, planning to remove it in stage1 and 
    implement it only in stage2


commit d972d1c9428f7ee762462dd0f074b6db6896790f
Author: mogud <mogud@qq.com>
Date:   Thu Dec 19 11:10:17 2019 +0800

    generate header in separate folder


    

    <h2 id="Accepted-Proposals"><a href="#toc-Accepted-Proposals">Accepted Proposals</a> <a class="hdr" href="#Accepted-Proposals">ยง</a></h2>

    <p>Here are proposals that have been accepted during the 0.6.0 release cycle,
    to give you an idea of the upcoming changes to Zig:</p>
    <ul>
      <li>TODO</li>
    </ul>
    
    

    <h1 id="Active-Open-Source-Projects-Using-Zig"><a href="#toc-Active-Open-Source-Projects-Using-Zig">Active Open-Source Projects Using Zig</a> <a class="hdr" href="#Active-Open-Source-Projects-Using-Zig">ยง</a></h1>

    <ul>
      <li>TODO</li>
    </ul>
    

    <h1 id="Funding-Status"><a href="#toc-Funding-Status">Funding Status</a> <a class="hdr" href="#Funding-Status">ยง</a></h1>

    <p>
    The Zig project is financially sustainable. It currently supports one
    full-time developer - the creator of the language, Andrew Kelley.
    </p>
    <p>
    If you flip through the previous release notes, you can see the number of commits and
    number of contributors per release increasing super-linearly. Merging pull requests
    and providing troubleshooting, support, and moderation for the quickly-growing community
    creates a strong demand on time that is too much for just one person.
    </p>
    <p>
    That is why I decided to start the <strong>Zig Software Foundation</strong>,
    a non-profit organization with the mission of raising the bar of software standards,
    ethics, and quality, and paying open source contributors for their valuable time.
    </p>
    <p>
    I hope you will stay tuned for an official announcement about the ZSF, which I expect
    to happen within 6 months.
    </p>
    

    <h1 id="Thank-You-Sponsors"><a href="#toc-Thank-You-Sponsors">Thank You Sponsors!</a> <a class="hdr" href="#Thank-You-Sponsors">ยง</a></h1>

    <p>
    Special thanks to those who <a href="https://github.com/users/andrewrk/sponsorship">sponsor Zig</a>.
    Because of you, Zig is driven by the open source community, rather than the goal of making profit.
    In particular, these fine folks sponsor Zig for $15/month or more:
    </p>
    <ul style="columns: 3">
      <li><a href="https://skunkwerks.at/">SkunkWerks, GmbH</a></li>
      <li><a href="https://www.hryx.net/">Stevie Hryciw</a></li>
      <li><a href="https://github.com/karrick">Karrick McDermott</a></li>
      <li><a href="https://jowl.app/">Daniel Axelrod</a></li>
      <li><a href="https://github.com/dimenus">Ryan Saunderson</a></li>
      <li><a href="https://github.com/drfuchs">drfuchs</a></li>
      <li><a href="http://severnatazvezda.com/">Rickard Andersson</a></li>
      <li><a href="http://haze.cool/">haze</a></li>
      <li><a href="https://github.com/iohzrd">iohzrd</a></li>
      <li><a href="http://interviewessentials.com/">Jessica Hargis</a></li>
      <li><a href="https://ross.codes/">Ross Kilgariff</a></li>
      <li><a href="https://kristoff.it/">Loris Cro</a></li>
      <li><a href="https://github.com/overdew">Jeff Kelley</a></li>
      <li><a href="http://raytracer.me/">Christoph Mรผller</a></li>
      <li><a href="https://github.com/rsimmons">Russel Simmons</a></li>
      <li><a href="https://github.com/ryanworl">ryanworl</a></li>
      <li><a href="http://santiagoandaluz.com/">Santiago Andaluz</a></li>
      <li><a href="https://github.com/vchakrav">vchakrav</a></li>
      <li><a href="https://github.com/sit-fyi">Yurii Rashkovskii</a></li>
      <li><a href="https://burntsushi.net/">Andrew Gallant</a></li>
      <li><a href="https://github.com/cshenton">Charles Shenton</a></li>
      <li><a href="https://dawnarc.com/">Neil Wang</a></li>
      <li><a href="http://www.fengb.me/">Benjamin Feng</a></li>
      <li><a href="https://filippo.io/">Filippo Valsorda</a></li>
      <li><a href="https://jayschwa.net/">Jay Petacat</a></li>
      <li><a href="https://github.com/qbradley">Quetzal Bradley</a></li>
      <li><a href="https://github.com/quag">Jonathan Wright</a></li>
      <li><a href="https://github.com/rahulunair">Rahul Nair</a></li>
      <li><a href="https://bitsandhops.com/">Richard Bishop</a></li>
      <li><a href="https://www.embark-studios.com/">Johan Andersson</a></li>
      <li><a href="http://joshtob.in/">Josh Tobin</a></li>
      <li><a href="https://github.com/rui314">Rui Ueyama</a></li>
      <li><a href="https://github.com/Sticksman">Felix Yuan</a></li>
      <li><a href="http://espians.com/">tav</a></li>
      <li><a href="http://zfeldman.com/">Zach Feldman</a></li>
      <li>Arto Bendiken</li>
      <li>Simon Cruanes</li>
      <li>Champ Yen</li>
      <li>Clipsey</li>
      <li>Luke I. Wilson</li>
      <li>Dan Boykis</li>
      <li>Eric</li>
      <li>Felix Jankowski</li>
      <li>fuzzwizard</li>
      <li>Gilbert</li>
      <li>Chris Heyes</li>
      <li>Jimmi Holst Christensen</li>
      <li>Hong Shick Pak</li>
      <li>Isaac Yonemoto</li>
      <li>Jesse Meyer</li>
      <li>Jethro Nederhof</li>
      <li>Jason Merrill</li>
      <li>Jack Halford</li>
      <li>Jimmy Zelinskie</li>
      <li>Keith Chambers</li>
      <li>Alon Zakai</li>
      <li>kristianhasselknippe</li>
      <li>Stefano Casillo</li>
      <li>Luis Alfonso Higuera Gamboa</li>
      <li>Charles Palmer</li>
      <li>Michael Lehmann</li>
      <li>Mirek Rusin</li>
      <li>Michaรซl Larouche</li>
      <li>Johann Muszynski</li>
      <li>Omar Akkila</li>
      <li>Emily A. Bellows</li>
      <li>Guillermo Rauch</li>
      <li>redj</li>
      <li>Robinson Collado</li>
      <li>rtroberts</li>
      <li>John Schmidt</li>
      <li>Scott J Maddox</li>
      <li>Lukas Attridge</li>
      <li>Neil Henning</li>
      <li>Audun Wilhelmsen</li>
      <li>Steve Perkins</li>
      <li>Clement Rey</li>
      <li>Thomas Ballinger</li>
      <li>Brian Orr</li>
      <li>vegecode</li>
      <li>Yiu Ming Huynh</li>
      <li>Abdulrhman A. AlKhodiry</li>
    </ul>
    
    </div>
  </body>
</html>
TODO convert std.foo.bar to foo.bar (and make hyperlinks?)
TODO search for "commit" as well as TODO
TODO the commits to master since aaf99371b22e816a4162391d799b9d22bba21120
TODO take a look at that wiki page by mike dusan, notable master branch commits
TODO hyperlinkify issue numbers
TODO run the html through the w3c validator to find html errors
